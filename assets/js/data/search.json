[ { "title": "쿠버네티스 완벽 가이드 / 마사야아오야마", "url": "/posts/book-kubernetes-guide/", "categories": "Blogging, Book", "tags": "Kubernetes", "date": "2023-06-11 10:50:00 +0900", "snippet": "1장 도커 복습과 Hello, Kubernetes1.1 도커 복습도커 컨테이너란?애플리케이션과 해당 애플리케이션을 실행하기 위한 실행환경을 패키징하여 애플리케이션을 쉽게 실행하기 위한 도구. 가상 머신은 하이퍼바이저를 이용하여 게스트 OS를 동작시키지만, 도커 컨테이너는 호스트 머신의 커널을 이용하여 네임스페이스 분리와 cgroups를 이용한 제어를 통해 독립적인 OS와 같은 환경을 만들 수 있다. 1 컨테이너당 1 프로세스 변경 불가능한 인프라(Immutable Infrastructure) 이미지로 생성한다. 경량의 도커 이미지로 생성한다 실행 계정은 root 이외의 사용자로 한다.도커 이미지# 도커 이미지 다운로드$ docker image pull ${image}# 도커 이미지 확인$ docker image ls# 도커 파일로 이미지 빌드$ docker image build -t ${image}:{tag}도커 이미지는 Dockerfile을 기반으로 빌드된다.사이즈별 이미지 최소 scratch : 초경량, 셸이 설치되지 않아 디버그가 어렵다 작다 alpine distroless : 특정 애플리케이션 런타임만 포함된 이미지 크다 ubuntu centos Universal Base Image 멀티 스테이지 빌드여러 컨테이너 이미지를 사용하여 처리하고 결과물만 실행용 컨테이너 이미지에 복사한다. 소스 코드 컴파일에 필요한 도구를 실제 애플리케이션을 기동시키는 컨테이너에 포함시키지 않아도 되기 때문에 이미지 사이즈를 줄일 수 있다.도커 레지스트리 도커 이미지 보관하는 저장소 서버 Docker Hub, Google Container Registry, Amazon Elastic Container Registry 등도커 허브에 이미지 업로드 하기도커 허브의 네임스페이스는 사용자의 이름이다.# 도커 허브 로그인$ docker login# 방법 1. 이미지 태그 변경 후 업로드# 이미지 태그 변경$ docker image tag ${image}:${tag} ${DOCKERHUB_USER}/${image}:${tag}# 도커 허브에 이미지 업로드$ docker image push ${DOCKERHUB_USER}/${image}:${tag}# 방법 2. 직접 푸시할 이름을 지정해 빌드$ docker image build -t ${DOCKERHUB_USER}/${image}:${tag}# 도커 허브 로그아웃$ docker logout도커 컨테이너 기동# 도커 컨테이너 기동 (localhost:12345 포트를 8080/TCP 포트로 전송)$ docker container run -d -p 12345:8080 sample-image:0.1# 애플리케이션 동작 확인$ curl http://localhost:123452장 왜 쿠버네티스가 필요할까?2.1 쿠버네티스란?컨테이너 오케스트레이션 엔진 컨테이너화된 애플리케이션의 배포, 확장 등의 관리를 자동화한다. 쿠버네티스, 도커 스윔, 아파지 메소스 등컨테이너 런타임 도커, containerd, cri-o 등쿠버네티스 노드 쿠버네티스에서 실제 컨테이너가 기동하는 노드(호스트기 되는 물리 머신이나 가상 머신)쿠버네티스 마스터 쿠버네티스 노드를 관리하는 노드컨테이너 어떤 애플리케이션을 실행하도록 빌드된 컨테이너 이미지를 기반으로 기동된 워크로드2.3 쿠버네티스를 사용하면 무엇을 할 수 있을까? 선언적 코드(매니페스트)를 통해 컨테이너를 배포한다 (IaC) YAML 형식, JSON 형식 스케일링/오토 스케일링 컨테이너 클러스터를 구성하여 여러 쿠버네티스 노드를 관리한다 레플리카를 배포해 부하 분산 및 다중화구조를 만든다 부하에 따라 레플리카 수를 자동으로 조절해 오토 스케일링한다 스케줄링 Affinity, Anti-Affinity 기능을 사용하여 스케줄링할 수 있다 리소스 관리 기본적으로 쿠버네티스 노드의 CPU, 메모리 여유 리소스 상태에 따라 스케줄링된다 클러스터 오토 스케일링 기능으로 리소스 사용 상태에 따라 쿠버네티스 클러스터의 노드도 자동 추가 삭제할 수 있다 자동화된 복구(self-healing) 표준으로 컨테이너 프로세스를 모니터링하고 정지를 감지하면 스케줄링을 실행하여 자동으로 재배포한다 로드 밸런싱과 서비스 디스커버리 로드밸런서 기능 서비스(Service), 인그레스(ingress) 사전 정의된 조건과 일치하는 컨테이너 그룹에 라우팅하는 엔드포인트 할당 서비스 디스커버리 각각의 마이크로 서비스가 정의된 복수의 매니페스트를 이용해 시스템을 전체 연계 데이터 관리 백엔드 데이터 스토어 etcd 클러스터를 통한 이중화 컨테이너나 서비스의 매니페스트 파일도 이중화 애플리케이션에서 사용되는 설정파일, 데이터베이스 인증 정보 저장 외부 에코시스템과의 연계 Ansible : 쿠버네티스에 컨테이너 배포 Apache Ignite : 쿠버네티스 서비스 디스커버리를 이용한 클러스터 생성, 스케일링 Fluentd : 쿠버네티스에 컨테이너 로그 전송 Jenkins : 잡 실행자용 컨테이너를 쿠버네티스에 배포 OpenStack : 클라우드 사업자와 연계한 쿠버네티스 구축 Prometheus : 쿠버네티스 모니터링 Spark : 잡을 쿠버네티스에서 네이티브로 실행 Kubeflow : 쿠버네티스에 ML 플랫폼 배포 Rock : 쿠버네티스에 분산 파일 시스템 배포 V itess : 쿠버네티스에 MySQL 클러스터 배포 그 외 다수 3장 쿠버네티스 환경 선택쿠버네티스 환경과 도구 로컬 쿠버네티스 : 물리머신 한 대에 구축하여 사용 미니큐브(Minikube) Docker Desktop for Mac / Window kind(Kubernetes in Docker) 쿠버네티스 구축 도구 큐브어드민(kubeadm) 쿠버네티스 공식 구축 도구 플라넬 노드 사이를 연결하는 네트워크에 오버레이 네트워크를 구성하여 쿠버네티스 클러스터 내부의 파드 간 통신을 구현한다. 랜처(Rancher) 쿠버네티스 구축과 운용을 지원하는 오픈 소스 컨테이너 플랫폼 중앙에서 랜처 서버를 기동시키고 관리자는 랜처 서버를 통해 쿠버네티스 클러스터를 구축하고 관리 그 외 엔서블(Ansible)을 사용한 큐브스프레이(Kubespray) 클라우드포메이션(CloudFormation)을 사용한 kube-aws 테라폼(Terraform)이나 클라우드 포메이션 형식의 파일을 출력할 수 있는 캅스(kobs) OpenStack Heat을 사용한 OpenStackMagnum 퍼블릭 클라우드 관리형 쿠버네티스 서비스 Google Kubernetes Engine(GKE) Azure Kubernetes Service(AKS) Elastic Kubernetes Service(EKS) 쿠버네티스 서비스 수준 목표(Service Level Objective, SLO)SIG-Scalability의 서비스 수준 지표와 서비스 수준 목표 API 응답 시간 단일 객체의 변경 API 요청에 대해 지난 5분동안 99%가 1초 내에 돌아올 것(일부 제외) 비스트리밍(non-streaming)의 API 요청에 대해 지난 5분 동안 99%가 아래 초 이내에 돌아올 것(일부 제외) 특정 리소스: 1초 네임스페이스 전체: 5초 클러스터 전체: 30초 파드 기동 시간 지난 5분 동안 99%가 5초 이내에 동작할 것 이미지 다운로드 시간이나 초기화 컨테이너(Init Container) 처리시간은 포함하지 않음 " }, { "title": "소프트웨어 아키텍처 101 / 마크 리처드, 닐 포드", "url": "/posts/book-software-architecture-101/", "categories": "Blogging, Book", "tags": "Architecture", "date": "2023-01-30 10:50:00 +0900", "snippet": "소프트웨어 아키텍처 101 - 마크 리처즈, 닐 포드1 서론소프트웨어 아키텍트의 길은 왜 분명하지 않을까? 직업 자체에 대한 명확한 정의가 없다 업무 범위가 방대하다 과거 모듈성, 컴포넌트, 패턴 등 순수 기술적인 부분 + MSA 등 계속해서 확대 소프트웨어 개발 생태계 발전에 따라 끊임없이 변화한다 관련 자료들은 역사적 연관성을 강조한다따라서 아키텍처를 공부하며 명심해야 할 것은, 현재의 환경에 맞는 결정을 하는 것이다.소프트웨어 아키텍처는 시스템의 청사진이다. 시스템 아키텍처를 이해하는 방법 중 하나는 아래와 같다. 아키텍처 특성 아키텍처 결정 반드시 지켜야 할 원칙 시스템 제약 조건을 형성 설계 원칙 가이드라인 시스템 구조 마이크로서비스, 레이어드, 마이크로커널 등 제1법칙 소프트웨어 아키텍처의 모든 것은 다 trade-off이다.제2법칙 ‘어떻게’보다 ‘왜’에 더 주목해야 한다.2 아키텍처 사고아키텍처 사고란 아키텍처와 설계의 차이를 알고 둘을 통합한 솔루션을 모색하는 것. 아키텍처: 비즈니스 요구사항 분석→아키텍처 특성, 스타일, 컴포넌트 구조 도출 설계 : 아티팩트 → 컴포넌트의 클래스 설계, UI, 소스 코드전통적인 역할 모델은 아키텍처→ 설계 단방향 이었으나, 제대로 된 아키텍처를 만들려면 소통의 단절을 부수고, 협력하여 프로젝트 생명 주기의 일부로 동기화 되어야 한다.트레이드오프 분석입찰 프로듀서 서비스가 입찰을 생성하고 그 금액을 입찰 캡처, 추적, 분석 서비스에 전달하는 경매 시스템을 설계한다고 가정한다.토픽을 이용한 서비스 간 통신을 이용할 경우 장점 아키텍처 확장성(extensibility) 입찰 이력을 조회하는 새로운 서비스를 도입하더라도 변경할 필요가 없는 구조이다. 서비스 디커플링 입찰 프로듀서 서비스는 입찰 정보를 어느 서비스가 어떻게 사용하는지 모른다 단점 데이터 액세스, 보안 문제 누구나 입찰 데이터에 액세스할 수 있으며 도청이 쉽다. 서로 다른 계약 지원 불가 토픽을 수신한 모든 서비스는 동일한 계약 및 데이터 세트를 받아야 한다. 모니터링과 프로그래밍 방식의 확장성 떨어짐 토픽 메시지 개수를 모니터링할 수 없고, auto-scaling 기능이 지원되지 않음 큐를 이용한 서비스 간 통신을 이용할 경우 장점 데이터 액세스, 보안 문제 큐를 수신하는 지정된 컨슈머만 접근 가능하다. 개별 계약 지원 토픽을 수신한 모든 서비스는 동일한 계약 및 데이터 세트를 받아야 한다. 모니터링과 프로그래밍 방식의 확장성 각 큐를 개별 모니터링 + 컨슈머 개별 로드 밸런싱 가능 단점 아키텍처 확장성 떨어짐 입찰 이력을 조회하는 새로운 서비스를 도입한다면, 서비스용 큐가 새로 필요하고, 프로듀서 서비스에 대한 변경이 불가피하다. 서비스 커플링 입찰 프로듀서 서비스는 입찰 정보가 어느 서비스에 어떻게 사용하는지 정확히 안다. 소프트웨어 아키텍처는 이런 트레이드오프를 분석하고 비즈니스 동인, 환경 등의 팩터에 따라 더 나은 방법을 택한다. (It depends!)아키텍트가 코딩 실무 능력 유지하는 방법 POC(proof-of-concept)를 자주 해본다 각 제품을 응용한 예제 코드를 작성하고 실행 결과를 비교하여 공수, 솔루션의 확장성, 성능, 내고장성등의 아키텍처 특성을 비교한다. 가능한 프로덕션 수준의 좋은 코드를 작성하여 레퍼런스 아키텍처나 다른 사람들이 참고할만한 샘플 코드로 만들자. 기술 부채 스토리나 아키텍처 스토리에 전념한다 버그를 잡는다 개발팀 프로세스 자동화 툴을 만든다 피트니스 함수를 사용해 아키텍처 컴플라이언스를 자동화한다 코드리뷰를 한다3 모듈성모든 플랫폼은 연관된 코드를 모듈로 묶는 방법을 지원한다. 또한 아키텍트가 분석해야할 메트릭, 피트니스 함수, 시각화 등 많은 도구가 모듈성에 기반한다.모듈성은 일종의 구성 원리(organizing principle)로 증가하는 소프트웨어 시스템 엔트로피를 모델링하고, 질서를 유지한다.모듈은 복잡한 구조를 만드는 데 쓰이는 각각의 표준화된 부품이나 독립적인 단위이다.아키텍트는 개발자각 코드를 어떻게 패키징하는지 알아야 한다. 여러 패키지가 단단히 커플링되어있으면 그 중 하나를 다른 작업에 사용하기 어려워진다.모듈성 측정응집응집(cohesion)은 모듈을 구성하는 구성요소가 서로 얼마나 연관되어 있는가를 나타낸다. 응집은 커플링보다 덜 정확한 메트릭으로 아키텍처 재량에 따라 다르게 측정될 수 있다.응집도의 측정 범위, 좋은 순서대로 기능적 응집(functional cohesion) 모듈의 각 파트는 나머지 파트와 연결되어 있고 기능상 필요한 모든 것이 모듈에 존재한다. 순차적 응집(sequential cohesion) 두 모듈이, 한쪽에 데이터를 출력하면 다른 쪽이 그것을 입력 받는 형태로 상호작용한다. 소통적 응집(communication cohesion) 두 모듈이, 각자 정보에 따라 작동하거나 어떤 출력을 내는 형태로 통신 체인을 형성한다. 절차적 응집(procedural cohesion) 두 모듈은 정해진 순서대로 실행된다. 일시적 응집(temporal cohesion) 모듈이 시점 의존성(timing dependency)에 따라 연관된다. 논리적 응집(logical cohesion) 기능이 아닌 논리적으로 응집되어있다. 자바 프로젝트의 StringUtils 패키지가 좋은 예. 동시적 응집(coincidental cohesion) 같은 소스 파일에 모듈 구성요소가 들어가있지만 아무런 연관성이 없다. LCOM(Lack of Cohesion in Methods)카이댐버와 케메러의 매서드의 응집 결여도이다. 공유 필드를 통해 공유되지 않는 메서드의 총 개수를 뜻한다.\\[LCOM96b = \\frac{1}{a}\\sum_{k=0}^{a}\\frac{m-\\mu(Aj)}{m}\\]커플링추상도(abstractness)는 추상 클래스, 인터페이스 등의 추상 아티팩트(abstract artifact)와 구상 아티팩트(concrete artifact, 구현체)의 비율, 즉 구현 대비 추상화를 나타낸다.\\[A(추상도) = \\frac{\\sum m^a}{\\sum m^c}\\]불안정도(instanbility)는 코드베이스의 변동성을 의미한다. 원심 커플링과 (구심 커플링 + 원심 커플링)의 비율로 계산한다.구심커플링은 컴포넌트, 클래스, 함수 등의 코드 아티팩트로 유입되는 접속 수를 의미한다.원심 커플링은 다른 코드 아티팩트로 유출되는 접속 수를 나타낸다.\\[I(불안정도)=\\frac{C^e}{C^e+C^a}\\]메인 시퀀스로부터의 거리(distance from the main sequence)추상도와 불안정도를 이용하여 이상적인 관계를 계산한다.\\[D = |A+I-1|\\] 그래프가 오른쪽 위로 치우칠 경우 쓸모없는 구역(zone of useless) 추상화를 너무 많이해서 사용하기 어려운 코드 그래프가 왼쪽 아래로 치우칠 경우 고통스러운 구역(zone of pain) 추상화를 거의 안하고 구현만 잔뜩 넣어 취약하고 관리하기 어려운 코드 커네이선스두 컴포넌트 중 한쪽이 변경될 경우 다른 쪽도 변경해야 전체 시스템 정합성이 맞는다면 커네이선스를 갖는다.커네이선스는 정적 커네이선스와 동적 커네이선스로 분류할 수 있다. 정적 커네이선스(static connascence) 소스 코드 레벨의 커플링으로 구심/원심 커플링을 발전시킨 개념 명칭 커네이선스(CoN) 여러 컴포넌트의 엔티티명이 일치해야 한다. 타입 커네이선스(CoT) 여러 컴포넌트의 엔티티 타입이 일치해야 한다. 의미 커네이선스(CoM) 또는 관례 커네이선스(CoC) 여러 컴포넌트에 걸쳐 어떤 값의 의미가 일치해야 한다. 예) 상수 대신 숫자를 하드코딩하는 경우 위치 커네이선스(CoP) 여러 컴포넌트는 값의 순서가 일치해야 한다. 예) 매개변수 알고리즘 커네이선스(CoA) 여러 컴포넌트는 특정 알고리즘이 일치해야 한다. 예) 보안 해시 알고리즘 동적 커네이선스(dynamic connascence) 런타임 호출을 분석하는 커네이선스 실행 커네이선스(CoE) 여러 컴포넌트의 실행 순서가 중요하다. 시점 커네이선스(CoT) 여러 컴포넌트의 실행 시점이 중요하다. 예) 동시에 실행 중인 두 스레드 때문에 경합 조건이 발생하여 공동 작업의 결과에 영향을 끼치는 경우 값 커네이선스(CoV) 상호 연관된 다수의 값들을 함께 변경한다. 예) 트랜잭션 식별 커네이선스(Col) 여러 컴포넌트가 동일한 엔티티를 참조한다. 예) 독립적인 두 컴포넌트가 분산 큐같은 자료구조를 공유해서 업데이트 하는 경우 커네이선스 속성은 다음과 같이 분석할 수 있다. 강도 아키텍트와 개발자는 더 나은 유형의 커네이선스를 리팩토링해서 코트베이스의 커플링 특성을 개선할 수 있다. 정적 커네이선스는 소스 코드 분석 또는 최신 도구를 이용해 쉽게 개선할 수 있다. 지역성 코드베이스의 모듈이 서로 얼마나 가까이 있는가 근접한 코드는 일반적으로 분리된 코드보다 높은 형태의 커네이선스를 가진다. 정도 커네이선스가 미치는 영향의 규모 소수의 클래스에 영향을 미치는가, 수많은 클래스에 영향을 미치는가 강한 정도의 커네이선스를 약한 정도의 커네이선스로 전환하는 것이 좋다. 1990년대 커네이선스의 문제점 아키텍트가 관심 있어하는 아키텍처의 구조보다 저수준 코드의 세부분을 관찰한다. 아키텍트가 내려야할 근본적인 결정에 관한 문제는 다루지 않는다.4 아키텍처 특성 정의아키텍트는 개발팀과 함께 도메인, 비즈니스 요구사항을 정의할 수 있지만, 주로 소프트웨어로 처리할 일 중 도메인 기능과 직접적인 관련이 없는 모든 것들, 즉 아키텍처 특성을 정의, 발견, 분석하는 일을 수행한다.비기능 요구사항, 품질 속성이라는 말도 많이 사용하지만 부정적인 인상을 주는 단어로 아키텍처 특성이라는 용어를 선호한다.아키텍처 특성의 기준은 다음과 같다. 비도메인 설계 고려 사항을 명시한다. 애플리케이션으로 처리할 일은 구체적인 요구사항으로 정리한다. 요구사항을 구현 하는 방법, 선택을 하게 된 이유와 관련된 운영/설계 기준을 명시한다. 설계의 구조적 측면에 영향을 미친다. 이 아키텍처 특성은 어떤 특별한 구조적 요소를 고려해야 하는가? 애플리케이션 성공에 절대적으로 중요하다. 아키텍처 특성에 따른 설계 복잡도 가중을 고려하여 가급적 아키텍처 특성을 작게 선정하는 일도 중요하다. 아키텍처의 명시적 특성과 암묵적 특성 명시적 특성 요구사항 정의서나 다른 지침서에 개시된 특성 암묵적 특성 요구사항 정의서에 없지만 프로젝트 성공을 위해 필요한 특성 가용성, 신뢰성, 보안 등 애플리케이션의 근간 아키텍처 특성 목록운영 아키텍처 특성 가용성(availability) 시스템이 얼마나 오랫동안 사용 가능해야 하는가 연속성(continuaility) 재해 복구 능력 성능(performance) 스트레스 테스트, 피크 분석, 기능의 사용 빈도 분석, 필요 용량, 응답 시간 등 복구성(recoverability) 비즈니스 연속성 요구사항, 백업 전략과 하드웨어 다중화 요건에 영향을 미친다. 신뢰성/안전(reliability/safety) 시스템에 페일 세이프가 필요한가? 시스템 실패 시 회사에 거액 손실이 발생하는가? 견고성(robustness) 프로그램 실행 중 인터넷 접속 끊김, 정전, 하드웨어 실패 등 에러 및 경계 조건을 감당하는 능력 확장성(scalability) 유저 수, 요청 수가 늘어나도 시스템이 그에 맞는 성능을 발휘하는 능력 구조 아키텍처 특성 설정성(configurability) 최종 유저가 편한 인터페이스를 통해 소프트웨어 설정을 쉽게 바꿀 수 있는가? 신장성(extensibility) 새로운 기능을 삽입하는 일의 중요성 설치성(installability) 필요한 모든 플랫폼에 쉽게 시스템을 설치할 수 있는가? 활용성/재사용(leverageability/reuse) 공통 컴포넌트를 여러 제품에 활용할 수 있나? 지역성(locality) 데이터 입력/조회하는 화면에서 다국어가 지원되는가? 유지보수성(maintainability) 시스템을 얼마나 쉽게 변경/개선할 수 있나? 이식성(portability) 하나 이상의 플랫폼에서 시스템을 실행할 수 있나? 지원성(supportability) 애플리케이션은 어느 정도의 기술 지원을 필요로 하나? 시스템에서 발생한 에러를 디버깅하려면 로깅 및 기타 기능이 어느 수준으로 뒷받침되어야 하는가? 업그레이드성(upgradeability) 이 애플리케이션/솔루션의 구 버전을 새 버전으로 쉽고 빠르게 업그레이드할 수 있는가? 아키텍처 공통 특성 접근성(accessibility) 색맹, 청각 장애인 등 모든 유저가 접근하는 데 불편함이 없는가? 보관성(archivability) 데이터를 따로 아카이빙해야 하나, 아니면 일정 시간 경과 후 삭제해야 하나? 인증(authentication) 유저가 본인이 맞다는 것을 증명하기 위해 필요한 보안 요구사항 인가(authorization) 유저가 애플리케이션에서 정해진 기능만 사용할 수 있도록 강제하는 보안 요구사항 합법성(legal) 시스템 운영상 법적 제약조건이 있는가? 프라이버시(privacy) 회사 내부 임직원의 트랜잭션을 외부에 드러내지 않는 기능 보안(security) 데이터를 암호화한 후 데이터베이스에 보관해야 하나? 내부 시스템 간 네트워크 통신도 암호화해야 하나? 원격 유저 액세스는 어떤 종류의 인증이 필요한가? 사용성/성취성(usability/achieveability) 유저가 애플리케이션/솔루션을 이용하여 원하는 목적을 달성하기 위해 필요한 교육/훈련 수준 최고의 아키텍처를 고집하지 말고 나쁜 것 중에서 제일 나은 아키텍처를 선택하라아키텍처가 내린 결정은 상충되는 여러 문제들이 뒤얽힌 트레이드오프로 귀결되는 경우가 많다.애자일 소프트웨어의 교훈과 같이, 가능한 한 아키텍처 설계를 꾸준히 반복해보는 것이 좋다.5 아키텍처 특성 식별아키텍처는 세 가지 출처 즉 도메인 관심사, 요구사항, 암묵적 도메인 지식에서 아키텍처 특성을 밝혀낸다.도메인 관심사에서 아키텍처 특성 도출도메인 이해관계자와 협력하여 주요 아키텍처 특성을 정의할 때 최종 목록을 가능한 한 짧게 하는 것이 좋다.너무 많은 아키텍처 특성을 수용하여 제네릭 아키텍처를 설계하려 하는 것은 안티패턴이다. 아키텍트와 개발자가 당초 의도했던 문제 영역의 해결을 시도하기도 전에 아키텍처가 너무 복잡해져버린다.주요 담당자들에게 가장 중요한 아키텍처 특성 3개를 선택하라고 한 다음 합의를 이끌어내는 것도 좋은 방법이다. 가장 중요한 것이 무엇일까 논의하고, 아키텍트가 중요한 결정을 내리기 전에 트레이드오프를 분석하는 데에도 도움이 된다.대부분의 아키텍처 특성은 핵심 도메인 이해관계자들의 의견을 듣고 도메인 관점에서 무엇이 중요한지 의견을 교환하면서 정리한다. 아키텍트와 도메인 이해관계자들이 다른 언어로 소통하는 문제를 막기 위해 도메인 관심사를 아키텍처 특성으로 옮기는 작업이 필요하다.요구사항에서 아키텍처 특성 도출요구사항 정의서에 명시된 문장에서 도출되는 아키텍처 특성도 있다. 아키텍트가 알고 있는 도메인 지식에서 도출되는 특성들이 있기 때문에 아키텍트가 도메인 지식을 갖고 있으면 이롭다.명시적 특성과 암묵적 특성 명시적 특성 필요한 설계의 일부로서 요구사항 정의서에 기술된다. 암묵적 특성 요구사항 정의서에 따로 없는 아키텍처 특성도 있지만 각각 중요한 설계 요소가 된다. 예) 가용성, 신뢰성, 보안이 있을 수 있고 중요도에 따라 우선순위가 달라질 수 있다. 6 아키텍처 특성의 측정 및 거버넌스아키텍처 특성 측정아키텍처 특성은 모호할 수 있어 객관적으로 정의할 필요가 있다. 물리학이 아니다 동일한 용어도 업계에서 바라보는 시각이 다르다. 법적인 상황이나 우발적으로 의미가 정해지는 경우도 있다. 정의가 너무 다양하다 개발자, 아키텍트, 운영자 모두 정의를 통일할 필요가 있다. 너무 복합적이다. 바람직한 아키텍처 특성은 대부분 더 작은 여러 특성들로 구성된다. 복합적인 특성을 더 잘게 나누면 다음과 같다. 운영적 특성 팀 목표에 따라 달성 가능한 수치를 목표로 삼는다. 예를 들어 확장성을 모니터링하는 비디오 스트리밍 서비스 업체라면 시간에 따라 어떤 추이를 보이는지 측정하고 통계 모델을 수립한다. 구조적 특성 내부 구조에 관한 특성은 목표치가 확실하지 않다. 이러한 경우 다른 메트릭과 공통 도구를 이용해서 코드 구조에 관한 부분을 볼 수 있다. 예를 들어 코드의 복잡도는 순환 복잡도(CC, cyclomatic complexity)라는 메트릭을 통해 측정할 수 있다. CC는 함수/메서드, 클래스, 또는 애플리케이션에서 코드 복잡도를 객관적으로 나타내는 지표 CC = E-N+2P (P는 연결된 컴포넌트 수) 업계 기준은 10 이하를 권장하나, 5 이하로 나와야 괜찬은 짜임새있는 코드 프로세스 측정 소프트웨어 개발 프로세스와 교차하는 아키텍처 특성도 있다. 민첩성은 시험성, 배포성 등의 특성으로 나눌 수 있는 복합적인 아키텍처 특성이다. 거버넌스와 피트니스 함수아키텍처 거버넌스란 아키텍트가 영향력을 행사하려는 모든 소프트웨어 개발 프로세스를 포괄한다.익스트림 프로그래밍에서 비롯된 소프트웨어 프로젝트의 자동화 움직임은 지속적 통합으로 발전하고, 운영도 자동화하는 데브옵스 체계에 이르렀으며 좋은 솔루션이 많이 등장하고 있다.아키텍처 피트니스 함수아키텍처 거버넌스의 여러 부문을 자동화하기 위해 피트니스 함수를 사용한다. 피트니스 함수는 결과가 목표에 얼마나 근접했는지를 나타내는 목표 함수이다.아키텍처 피트니스 함수는 어떤 아키텍처 특성(또는 그런 특성들의 조합)의 객관적인 무결성을 평가하는 모든 매커니즘이다.아키텍처 특성에 따라 피트니스 함수를 다양한 도구로 구현할 수 있다.모듈성의 다양한 측면을 태스트하는 피트니스 함수를 소개한다.순환 의존성순환 의존성이 형성되면 개발자가 어느 한 컴포넌트를 재사용하기 위해 그에 딸린 다른 컴포넌트들도 함께 가져와야 하므로 모듈성이 매우 떨어진다. 또 컴포넌트 간에 커플링이 증카할 수록 아키텍트는 안티패턴에서 헤어나오지 못한다. 아키텍트는 JDepend라는 메트릭 도구로 패키지 간 의존성을 체크할 수 있다. 이 테스트를 프로젝트의 지속적 빌드의 일부로 장치하여 순환 참조를 방지할 수 있다.‘메인 시퀀스로부터의 거리’ 피트니스 함수‘메인 시퀀스로부터의 거리’와 같은 난해한 메트릭도 피트니스 함수를 이용해 확인할 수 있다. JDepend로 수용 가능한 임계치를 설정하고 클래스가 범위를 벗어나면 테스트를 실패 처리한다.아키텍트는 개발자에게 피트니스 함수 사용을 권하기 전에 정확한 목적을 이해할 수 있도록 설명해야한다.최근 수년 간 피트니스 함수 도구는 점점 더 정교해졌고 목적에 따라 특화되는 추세이다. JUnit의 영향을 받아 탄생한 ArchUnit은 레이어 간의 올바른 관계를 정의하고 실천하는 검증 피트니스 함수 코드를 제공한다. 넷플릭스의 카오스 멍키(Chaos Monkey), 시미안 아미(Simian Army)도 피트니스 함수의 응용 사례이다.7 아키텍처 특성 범위전통적으로는 아키텍처 특성의 범위를 시스템 레벨에 두었으나, 현대적인 공학 기술의 등장과 마이크로서비스 등의 아키텍처 스타일이 가능해지면서 아키텍처 특성의 범위는 좁아졌다.커플링과 커네이선스구심/원심 커플링과 같은 코드 레벨의 커플링 메트릭은 아키텍처 분석용으로는 너무 세분도가 높다. (전체 시스템의 구조를 이해하는데 적합하지 않다) 커네이선스는 커플링을 보완하기 위한 메트릭이다.두 컴포넌트 중 한쪽이 변경될 경우 다른 쪽도 변경해야 전체 시스템의 정합성이 맞는다면 커네이선스를 가지고 있는 것이다. 정적 커네이선스 정적 코드 분석으로 발견할 수 있다. 예) 동일한 클래스를 공유한다. 동적 커네이선스 런타임 동작과 관련되어있다. 예) 서비스간 호출을 하는 경우 동기 예) 분산 서비스간 동기 호출 비동기 예) 이벤트 기반 아키텍처의 비동기 호출 아키텍처 퀀텀과 세분도아키텍처 퀀텀이란 높은 응집도(high functional cohesion)와 동기적 커네이선스(synchronous connascence)를 가진, 독립적으로 배포 가능한(independently deployable) 아티팩트이다. 독립적으로 배포 가능 아키텍처 퀀텀은 아키텍처의 다른 파트와 독립적으로 작동되는 모든 필수 컴포넌트를 포함한다. 높은 기능 응집도 응집도는 컴포넌트 설계에 따라 구현된 코드가 얼마나 목적에 맞게 통합되어 있는지를 나타낸다. 예를 들어 특정 도메인 컴포넌트는 응집도가 높고, Utility 컴포넌트는 응집도가 낮다. 동기적 커네이선스 아키텍처 퀀텀을 형성하는 애플리케이션 콘텍스트 내부 또는 분산 서비스간의 동기 호출을 의미한다. 두 서비스가 두드러진 차이를 나타내는 경우, 호출부의 확장성이 훨씬 좋을 경우 타임아웃과 신뢰성 문제가 일어날 것이다. 8 컴포넌트 기반 사고컴포넌트란 모듈(연관된 코드의 묶음)을 물리적으로 패키징한 것이다.컴포넌트 범위가장 단순한 컴포넌트는 클래스보다 한 단계 높은 수준의 모듈로 코드를 래핑하는 것이고 보통 이를 라이브러리라고 한다. 라이브러리는 대개 호출부 코드와 동일한 메모리 주소에서 실행되며 해당 언어의 함수 호출 매커니즘을 이용해 통신한다. 또한 라이브러리는 일반적으로 컴파일 타임에 의존한다.컴포넌트는 아키텍처에서 서브시스템이나 레이어 형태로 나타나며 배포 가능한 작업의 단위이다.서비스는 또다른 종류의 컴포넌트로서 자신의 주소공간에서 실행되며, TCP/IP 같은 저수준 네트워크 프로토콜이나 REST, 메시지 큐 같은 고수준 포맷을 통해 통신한다. 마이크로서비스 아키텍처에서의 서비스는 배포 가능한 독립적인 단위이다.아키텍트 역할아키텍트는 아키텍처 내부의 컴포넌트를 정의, 개선, 관리, 통제하는 일을 한다. 소프트웨어 아키텍트는 아키텍처 특성과 소프트웨어 시스템 요구사항을 종합하여 비즈니스 분석가, 분야별 전문가, 개발자, QA 엔지니어, 운영자 엔터프라이즈 아키텍트와 함께 소프트웨어 초기 설계를 한다.아키텍트는 클래스 설계에 참여해서도 안되고 시스템의 세세한 설계 결정에 관여해서도 안된다.아키텍처 분할최상위 아키텍처를 분할하는 두가지 방법 기술 분할 - 레이어드 아키텍처 시스템 기능을 기술적인 능력, 즉 프레젠테이션, 컨트롤러, 서비스, 퍼시스턴스 등으로 분할 관련 코드를 쉽게 찾을 수 있다. 콘웨이 법칙의 실현이다 시스템을 설계하는 조직은 그 조직의 소통 구조를 그대로 옮겨 놓은 설계도를 그릴 수밖에 없다. 기술 관심사의 분리로 유용한 수준의 디커플링을 만든다. 장점 커스텀 코드가 명확하게 분리된다. 레이어드 아키텍처 패턴에 더 가깝게 맞출 수 있다. 단점 전역 커플링이 높다. 따라서 공통 또는 로컬 컴포넌트 중 하나라도 변경되면 다른 컴포넌트들이 영향을 받을 가능성이 높다. 개발자가 공통 레이어, 로컬 레이어 양쪽에 도메인을 복제해야 할 수도 있다. 데이터 레벨의 커플링이 높다. 따라서 나중에 분산 시스템으로 옮기려고 할 경우 작업이 어렵다. 도메인 분할 - 모듈러 모놀리스 도메인이나 워크 플로에 따라 아키텍처를 분할한다. 컴포넌트는 서로 중첩될 때가 많기 때문에 각 컴포넌트는 퍼시스턴트 라이브러리를 사용하거나 별도의 레이어에 비즈니스 규칙을 둘 수 있다. 도메인에 초점을 두어 프로젝트에서 가장 자주 발생하는 변경의 유형들이 더 확실하게 반영된다. 장점 세부 구현보다 비즈니스 기능에 더 가깝게 모델링된다. 역 콘웨이 전략을 활용하여 도메인별 다목적팀(cross-functional team)을 구성하기 쉽다. 모듈러 모놀리스와 마이크로서비스 아키텍처 스타일에 더 가깝다. 메시지 흐름이 문제 영역과 일치한다. 데이터와 컴포넌트를 분산 아키텍처로 옮기기 쉽다. 단점 유저 코드가 여기저기 널려있다. 컴포넌트 식별 흐름컴포넌트 식별은 후보를 도출하고 피드백을 통해 다듬어가는 과정을 반복하는 것이 가장 좋다. 초기 컴포넌트 식별 아키텍트는 소프트웨어 프로젝트의 소스 코드가 생기기 전에 적용할 최상위 분할의 유형에 따라 최상위 컴포넌트를 어디서부터 시작할지 결정해야 한다. 요구사항을 컴포넌트에 할당 초기 컴포넌트를 식별한 후, 아키텍트는 컴포넌트 요구사항을 대입해서 잘 맞는지 확인한다. 역할 및 책임 분석 컴포넌트에 스토리를 대입할 때 아키텍트는 요구사항을 파악하는 단계에서 밝혀진 역할과 책임도 살펴보고 세분도가 적합한지 확인한다. 아키텍처 특성 분석 커포넌트에 요구상을 대입할 때 아키텍트는 앞서 식별한 아키텍처 특성들이 컴포넌트 분할 및 세분도에 어떤 역할을 미치는지 살펴봐야 한다. 컴포넌트 재구성 소프트웨어 프로젝트 도중 어떤 미지의 이슈가 튀어나올지 알 수 없다. 컴포넌트 설계를 반복 접근하는 방식이 정말 중요하다. 아키텍처 퀀틈 딜레마: 모놀리식 vs 분산 아키텍처아키텍처 스타일은 저마다 트레이드 오프가 있다. 그러나 근본적인 설정으로 설계 프로세스 중에서 식별된 아키텍처 퀀텀 수에 죄우된다. 만약 시스템이 단일 퀀텀만으로 가능하다면 모놀리스 아키텍처가 장점이 더 많다. 반면 컴포넌트 아키텍처 특성이 모두 달라 지는 경우 이를 수용할 수 있는 분산 아키텍처가 필요하다.아키텍처 퀀텀을 사용하면 초기 설계 단계에서 아키텍처의 근본적인 설계를 결정할 수 있으므로 아키텍처 특성 범위와 커플링을 분석하는 방법이 장점이다.컴포넌트 식별 흐름컴포넌트 식별은 후보를 도출하고 피드백을 통해 다듬어가는 과정을 반복하는 것이 가장 좋다. 초기 컴포넌트 식별 아키텍트는 소프트웨어 프로젝트의 소스 코드가 생기기 전에 적용할 최상위 분할의 유형에 따라 최상위 컴포넌트를 어디서부터 시작할지 결정해야 한다. 요구사항을 컴포넌트에 할당 초기 컴포넌트를 식별한 후, 아키텍트는 컴포넌트 요구사항을 대입해서 잘 맞는지 확인한다. 역할 및 책임 분석 컴포넌트에 스토리를 대입할 때 아키텍트는 요구사항을 파악하는 단계에서 밝혀진 역할과 책임도 살펴보고 세분도가 적합한지 확인한다. 아키텍처 특성 분석 컴포넌트에 요구상을 대입할 때 아키텍트는 앞서 식별한 아키텍처 특성들이 컴포넌트 분할 및 세분도에 어떤 역할을 미치는지 살펴봐야 한다. 컴포넌트 재구성 소프트웨어 프로젝트 도중 어떤 미지의 이슈가 튀어나올지 알 수 없다. 컴포넌트 설계를 반복 접근하는 방식이 정말 중요하다. 아키텍처 퀀텀 딜레마: 모놀리식 vs 분산 아키텍처아키텍처 스타일은 저마다 트레이드 오프가 있다. 그러나 근본적인 설정으로 설계 프로세스 중에서 식별된 아키텍처 퀀텀 수에 죄우된다. 만약 시스템이 단일 퀀텀만으로 가능하다면 모놀리스 아키텍처가 장점이 더 많다. 반면 컴포넌트 아키텍처 특성이 모두 달라 지는 경우 이를 수용할 수 있는 분산 아키텍처가 필요하다.아키텍처 퀀텀을 사용하면 초기 설계 단계에서 아키텍처의 근본적인 설계를 결정할 수 있으므로 아키텍처 특성 범위와 커플링을 분석하는 방법이 장점이다.9 기초기초적인 아키텍처 패턴을 익힌다. 구조적 측면과 어떤 종류의 아키텍처 특성이 알맞은지, 통상적인 배포 모델과 데이터 전략을 이해할 수 있다.기초 패턴진흙잡탕실제 내부 구조라 할 만한 것은 없는, 데이터베이스를 직접 호출하는 이벤트 핸들러를 가진 단순한 스크립팅 애플리케이션이며, 아키텍처 안티패턴이다. 코드 품질 및 구조에 관한 거버넌스가 결여된 탓에 많은 프로젝트가 이렇게 된다.유니터리 아키텍처소프트웨어 태동기에 단 1대의 컴퓨터에서 동작하는 아키텍처이다.클라이언트/서버프론트엔드와 백엔드로 기술적 기능을 분리하는 대표적인 기본 아키텍처이다. 시대와 컴퓨팅 파워에 따라 여러 형테로 존재해왔다.데스크톱 + 데이터베이스 서버초창기 PC 아키텍처에서는 윈도우와 같은 UI를 기반으로 리치 데스크톱 애플리케이션을 개발하도록 지원했다. 프레젠테이션 로직은 데스크톱에 두고 계산량이 많은 액션은 별도의 사양이 탄탄한 데이터베이스 서버로 분리한다.브라우저 + 웹서버현대 웹 개발 시대에서 웹 브라우저가 웹 서버에 접속, 그리고 웹 서버는 데이터베이스 서버에 접속하는 형태가 일반화되었다. 데이터베이스와 웹 서버가 모두 운영 센터 내부의 동급 머신에서 운용되므로 이 구조를 2티어 아키텍처로 바라보는 아키텍트들도 있다.3티어1990년대 후반 인기를 끈 아키텍처이다. 고성능 데이터베이스 서버를 사용하는 데이터베이스 티어, 애플리케이션 서버가 관리하는 애플리케이션 티어, 프런트엔드 티어로 구성한다. 분산 아키텍처에 적합한 공통 객체요청 브로커 아키텍처(CORBA), 분산 컴포넌트 객체 모델(DCOM) 같은 네트워크 수준 프로토콜과 적합하다.모놀리식 대 분산 아키텍처아키텍처 스타일을 크게 분류하면 모놀리식과 분산형 두 종류이다.모놀리식 레이어드 아키텍처 파이프라인 아키텍처 마이크로커널 아키텍처분산형 서비스 기반 아키텍처 이벤트 기반 아키텍처 공간 기반 아키텍처 서비스 지향 아키텍처 마이크로서비스 아키텍처분산 아키텍처는 성능, 확장성, 가용성 측면에서 강력하지만 트레이드 오프가 수반된다.분산 컴퓨팅의 8가지 오류 오류 #1 : 네트워크는 믿을 수 있다 분산 아키텍처 특성상 서비스 간에 이동하는 네트워크에 의존하므로 시스템의 신뢰도가 떨어질 수 있다. → 타임아웃 같은 장치를 마련하거나 서비스 간 회로 차단기(서킷 브레이커)를 두는 방법이 있다. 오류 #2 : 레이턴시는 0이다 분산 아키텍처에서 원격 액세스 프로토콜을 통해 수행하면 레이턴시는 0이 될 수 없다. → 운영환경에서의 평균 레이턴시를 알아야 한다. 오류 #3 : 대역폭은 무한하다 마이크로서비스 분산 아키텍처에서 자잘한 서비스들 간에 주고 받는 통신이 대역폭을 상당히 점유하여 네트워크가 느려질 수 있다. 레이턴시(오류 #2)와 신뢰성(오류 #1)에 영향을 미친다. → 스탬프 커플링(stamp coupling)을 해결한다. 프라이빗 REST API 엔드포인트를 둔다. 계약에 필드 셀렉터를 사용한다. GraphQL로 계약을 분리한다. 컨슈머 주도 계약(CDC, consumer-driven contact)과 값 주도 계약(VBC, value-driven contact)을 병용한다. 내부 메시징 엔드포인트를 사용한다. 오류 #4 : 네트워크는 안전하다 분산 아키텍처의 경우 더 넓은 영역이 악의적인 외부의 위협과 공격에 노출된다. 모든 엔드포인트에 보안이 적용되어야 하므로 성능이 떨어질 수밖에 없다. 오류 #5 : 토폴로지는 절대 안 바뀐다 네트워크를 구성하는 모든 라우터, 허브, 스위치, 방화벽, 네트워크, 어플라이언스 등 전체 네트워크 토폴로지는 변할 수 있다. → 아키텍트는 운영자, 네트워크 관리자와 항시 소통하며 무엇이, 언제 변경되었는지 알아야 한다. 오류 #6 : 관리자는 한 사람 뿐이다 분산 아키텍처에서 많은 소통과 협력이 필요하다. 오류 #7 : 운송비는 0이다 분산 아키텍처는 하드웨어, 서버, 게이트웨이, 방화벽, 신규 서브넷, 프록시 등 리소스가 더 많이 동원되므로 모놀리식 아키텍처보다 비용이 훨씬 많이 든다,. 오류 #8 : 네트워크는 균일하다 온갖 종류의 하드웨어가 모두 잘 맞물려 동작하는 것은 아니다. 네트워크 신뢰성, 레이턴시, 대역폭도 영향을 받을 수 있다. 또한 다음과 같은 문제점이 있다. 분산 로그 분산 로깅에 대한 솔루션과 패턴이 필요하다. 분산 트랜잭션 분산 트랜잭션을 관리하기 어렵다. 최종 일관성이라는 개념을 바탕으로 분리된 배포 단위에서 처리된 데이터를 알 수 없는 시점에 일관된 상태로 동기화한다. (확장성, 성능 가용성과 데이터 일관성, 무결성을 트레이드오프) 계약 관리 및 버저닝 분산 아키텍처는 분산된 서비스와 시스템을 제각기 다른 팀과 부서가 소유하기 때문에 계약 유지보수가 어렵다. 10 레이어드 아키텍처 스타일가장 흔한 아키텍처 스타일중 하나이다. 콘웨이 법칙과 어울리고 단순하고 대중적이어서 모든 애플리케이션의 사실상 표준(de facto standard) 아키텍처이다.토폴로지내부 컴포넌트를 논리적으로 수평한 레이어들로 구성하며 일반적으로 아래의 4개 표준 레이어로 구성한다. 프레젠테이션 레이어 비즈니스 레이어 퍼시스턴트 레이어 데이터베이스 레이어관심사의 분리 개념 덕분에 레이어드 아키텍처 스타일은 아키텍처 내부의 역할 및 책임 모델을 효과적으로 구성할 수 있다. 장점 : 개발자 본인의 기술 역량을 도메인 기술적인 부분에 집중시킬 수 있다. 단점 : 전체적인 민첩성이 떨어진다.기술 역할에 따라 분리하기 때문에 도메인 주도 설계 방식과는 잘 맞지 않는다.레이어 격리레이어 격리란 어느 아키텍처 레이어에 변경이 일어나도 다른 레이어에 있는 컴포넌트는 영향을 받지 않기에 레이어 간 계약은 불변임을 의미한다.레이어를 격리하면 모든 레이어를 다른 레이어에 영향을 주지 않고 교체할 수 있다.레이어 추가레이어를 개방하는 것이 유리한 때가 있다.예를 들어 비즈니스 레이어에 구현한 공통 비즈니스 기능이 구현된 객체를 프레젠테이션 레이어에서 직접 사용할 수 없도록 아키텍처 결정을 했다고 가정하자. 개방/폐쇄 개념을 이용하여 서비스 레이어를 새로 추가하고, 비즈니스 레이어에 개방하여, 만약 비즈니스 레이어에서 퍼시스턴트 레이어에 접근한다면 통과하도록 설계한다.개방/폐쇄 개념은 아키텍처 레이어 간 관계와 요청 흐름을 정의할 때 유용하다.기타 고려사항아키텍처 스타일을 결정하지 못했다면 레이어드 아키텍처가 좋은 출발점이 될 것이다.레이어드 아키텍처에서는 아키텍처 싱크홀(architecture sinkhole)안티패턴을 조심해야 한다.파레토 법칙(pareto principle)에 의해 전체 요청의 20%가 싱크홀 정도면 괜찮은 수준이다.11 파이프라인 아키텍처 스타일파이프라인 아키텍처는 애플리케이션 로직을 필터 타입에 따라 나누는 기술 분할 아키텍처이다.파이프와 필터 아키텍처라고도 불린다.기능을 개별 파트로 분리하기로 결정하는 순간부터 이 패턴이 수반된다.Bash나 Zsh와 같은 유닉스 터미널 쉘 언어의 기초 원리이며, 함수형 언어와 연관이 깊다.토폴로지파이프라인 아키텍처는 다수의 파이프와 필터로 구성된다.파이프파이프란 한 소스에서 입력을 받아 다른 소스로 출력하는 필터 간 통신 채널이다.성능상의 이유로 단방향, 점대점 방식으로 구성한다.페이로드 데이터는 고성능에 유리한 적은 양의 데이터를 선호한다. 그러나 어떤 포맷이라도 가능하다.필터필터는 다른 필터와 독립적이며, 일반적으로 무상태성이다. 자기완비형(self-contained)이다.필터는 한 가지 태스크만 수행하며, 여러 필터를 이어 붙여 복합 태스크를 수행할 수 있다.파이프라인 아키텍처 스타일에서 네 가지 종류의 필터가 있다. 프로듀서 프로세스의 시작점이다. 아웃바운드만 있어서 소스라고도 한다. 변환기(transformer) 입력을 받아 필요시 일부 또는 전체 데이터를 변환한 후 결과를 아웃바운드 파이프로 전달한다. 함수형 프로그래머는 이 기능을 맵(map)이라고 부른다. 테스터 입력을 받아 테스트를 하고 결과에 따라 필요시 결과를 생산한다. 함수형 프로그래머는 이 기능을 리듀스(reduce)라고 부른다. 컨슈머 파이프라인 흐름의 종착역이다. 파이프라인 프로세스의 최종 결과를 데이터베이스에 저장하거나, 유저 인터페이스에 표시한다. 12 마이크로커널 아키텍처 스타일마이크로커널 아키텍처는 플러그인 아키텍처라고도 한다.토폴로지마이크로커널 아키텍처 스타일은 코어 시스템과 플러그인 컴포넌트라는 두가지 아키텍처 요소로 구성된다.애플리케이션 로직을 독립적인 플러그인 컴포넌트와 기본 코어 시스템에 분산하여 확장성, 적응성, 애플리케이션 기능 분리, 커스텀 처리 등을 수행한다.코어 시스템코어 시스템은 시스템을 실행시키는 데 필요한 최소한의 기능을 정의한다.이는 순환 복잡도를 없애고 별도의 플러그인 컴포넌트를 장착하여 확장성, 유지보수성 그리고 시험성을 향상시킨다.코어 시스템은 규모와 복잡성에 따라 레이어드 아키텍처나 모듈러 모놀리스로 구현할 수 있다. 경우에 따라 코어 시스템을 별도 배포하는 도메인 서비스로 나누어 서비스 별 도메인에 특정한 플러그인 컴포넌트를 둘 수 있다.프레젠테이션 레이어는 코어 시스템에 내장하거나 별도의 UI를 구현하고 코어시스템은 백엔드 서비스를 제공한다.플러그인플러그인 컴포넌트는 특수한 처리 로직, 부가 기능, 그리고 코어 시스템을 개선/확장하기 위한 커스텀 코드가 구현된 스탠드얼론 컴포넌트이다.플러그인 컴포넌트는 컴파일 기반 또는 런타임 기반으로 만들 수 있다. 컴파일 기반 플러그인 컴포넌트 관리하기 편하다. 그러나 변경, 추가, 삭제 시 전체 모놀리식 애플리케이션을 재배포해야 한다. 런타임 기반 플러그인 컴포넌트 런타임에 코어 시스템이나 다른 플러그인을 재배포하지 않고도 바로 추가/삭제가 가능하다. 자바 OSGI(Open Service Gateway Initiative), 펜로즈, 직소, 프리즘 등의 프레임워크를 통해 관리한다. 플러그인 컴포넌트는 코어 시스템과 일반적으로 점대점(point-to-point) 통신을 한다 즉, 코어 시스템에 플러그인을 연결하는 파이프는 대부분 플러그인 컴포넌트의 진입점 클래스를 호출하는 메서드나 함수 코드이다.반드시 점대점 통신을 해야 하는 것은 아니다.각 플러그인을 스탠드얼론 서비스 또는 컨테이너에 구현한 마이크로서비스로 만들어 REST나 메시징 등 다른 방법으로 기능을 호출하는 방법도 있다.그러나 이 토폴로지는 코어 시스템이 모놀리식으로, 여전히 단일 아키텍처 퀀텀이다.레지스트리플러그인 레지스트리는 플러그인 명칭, 데이터 계약, 세부 원격 액세스 프로토콜 등 각 플러그인 모듈 정보를 코어 시스템에게 제공한다.레지스트리는 코어 시스템이 소유한 내부 맵 구조일 수 있고, 레지스트리 및 디스커버리 도구(예, 아파치 주키퍼나 콘술)가 코어 시스템이나 외부 배포된 시스템에 내장된 구조일 수 있다.13 서비스 기반 아키텍처 스타일서비스 기반 아키텍처는 마이크로서비스 아키텍처 스타일의 일종이다.토폴로지별도로 배포된 유저 인터페이스와 원격 서비스(도메인 서비스) 그리고 모놀리스 데이터베이스로 이루어진 대규모 분산 레이어 구조이다.서비스 배포 방식에서 컨테이너화가 필수는 아니다.서비스는 원격 액세스 프로토콜로 유저 인터페이스 외부에서 접속할 수 있다. 프로토콜은 일반적으로 REST를 많이 사용하지만, 메시징, 원격 프로시저 호출(RPC) , SOAP도 사용 가능하다.유저 인터페이스는 프록시나 게이트웨이로 구성된 API 레이어를 통해 서비스에 접속할 수 있지만, 대개 서비스 로케이터 패턴에 따라 유저 인터페이스, API 게이트웨이, 프록시에 내장된 유저 인터페이스를 직접 액세스 한다.서비스 설계 및 세분도서비스 기반 아키텍처 스타일의 도메인 서비스는 일반적으로 단위가 크기 때문에 API 퍼사드 레이어, 비즈니스 레이어, 퍼시스턴트 레이어로 구성된 레이어드 아키텍처 스타일로 설계하는 것이 일반적이다.모듈러 모놀리스 아키텍처 스타일과 같이 서브도메인을 이용해 도메인을 분할하는 방법도 사용된다.세분도도메인 서비스는 세분도가 크기 때문에 단일 도메인 서비스에서 데이터 무결성을 보장하기 위해 ACID 데이터베이스 트랜잭션을 사용한다.반면 마이크로서비스처럼 분산도가 높은 아키텍처는 서비스를 더 잘게 나누어 BASE(기본적 가용성 basic availability, 소프트 상태 soft state, 최종 일관성 eventual consistency) 분산 트랜잭션 기법을 사용한다.최종 일관성을 기반으로 ACID 트랜잭션 레벨의 데이터 무결성은 지원하지 않는다.반면 도메인 서비스는 변경 영향도가 크다는 트레이드 오프가 있다.데이터베이스 분할서비스 기반 아키텍처 스타일은 일반적으로 주어진 애플리케이션 콘텍스트에서 서비스 수가 적은 편이라 단일 모놀리식 데이터베이스를 공유한다.그러나 데이터베이스 커플링은 테이블 스키마 변경 시 문제가 될 수 있다.엔티티 객체가 공유하는 단일 공유 라이브러리를 사용하면 데이터베이스 테이블 하나를 바꾸어도 모든 서비스에 영향을 미친다.변경 영향도와 리스크를 낮추는 방법은 연합 공유 라이브러리(federated shared library)를 통해 데이터베이스를 논리 분할하는 것이다.이러한 방식은 특정 논리 도메인에 속한 테이블을 변경해도 해당 엔티티 객체가 포함된 해당 공유 라이브러리를 사용하는 서비스만 영향을 받을 뿐, 그 밖의 서비스는 영향을 받지 않는다.또한 테이블과 해당 엔티티 객체의 변경 영향도를 낮추는 한가지 방법은, 공통 엔티티 객체를 버전 관리 시스템에서 락킹하고 수정 권한을 데이터베이스 팀에만 부여하는 것이다.14 이벤트 기반 아키텍처 스타일이벤트 기반 아키텍처는 확장성이 뛰어난 고성능 애플리케이션 개발에 유리한 비동기 분산 아키텍처 스타일이다.이벤트를 비동기 수신 및 처리하는 별도의 이벤트 처리 컴포넌트들로 구성된다.스탠드얼론 아키텍처 스타일 또는 이벤트 기반 마이크로 서비스 아키텍처와 같은 다른 아키텍처 스타일에 내장할 수 있다.애플리케이션은 일반적으로 요청 기반 모델을 사용하여, 어떤 액션을 수행하도록 요청하면 요청 오케스트레이터가 접수한다. 요청 오케스트레이터는 다양한 요청 프로세서에 확정적이고 동기적으로 요청을 전달한다. 요청 프로세서는 요청을 받아 데이터베이스에서 정보 조회 수정 등을 통해 작업을 수행한다.반면, 이벤트 기반 모델은 특정 상황에 대응하여 이벤트에 알맞은 액션을 취한다.토폴로지이벤트 기반 아키텍처의 주요 토폴로지는 브로커 토폴로지와 중재자 토폴로지로 나뉜다.브로커 토폴로지신속한 응답과 동적인 이벤트 처리 제어가 필요할 때 중앙에 이벤트 중재자가 없다. 경량 메시지 브로커(RabbitMQ, ActiveMQ, HornetQ 등)를 통해 메시지를 브로드캐스팅한다. 비교적 이벤트 처리 흐름이 단순하고, 중앙에서 이벤트를 조정할 필요가 없을 때 사용한다.아래와 같이 구성된다 이벤트 브로커 시작 이벤트를 받는다. 시작 이벤트 - 전체 이벤트의 흐름을 개시하는 이벤트 이벤트 브로커의 이벤트 채널이 시작 이벤트를 처리한다. 이벤트 프로세서 이벤트 브로커에서 시작 이벤트를 받아 관련된 처리 작업을 마친다. 처리 이벤트를 생성한다. 시스템에 비동기적으로 한 일을 알린다. 이 작업은 최종 이벤트 프로세서가 한 일에 아무도 관심이 없을 때 까지 반복된다.브로커 토폴로지에서는 다른 이벤트 프로세서의 관심 여부와 무관하게 각 이벤트 프로세서가 자신이 한 일을 모두에게 알리는 것이 아키텍처 확장성 측면에서 바람직하다.장점 이벤트 프로세서가 디커플링된다 확장성이 높다 응답성이 우수하다 성능이 우수하다 내고장성이 뛰어나다단점 시작 이벤트와 연괸된 전체 워크플로를 제어할 수 없다. 특정 트랜잭션이 언제 끝났는지 모른다. 에러 처리가 어렵다. (중재자가 없기 때문에) 처리에 실패해도 다른 파트는 그 사실을 모른다.중재자 토폴로지이벤트 처리 워크플로를 제어해야할 때이벤트 중재자를 사용하며 브로커 토폴로지의 단점을 보완한다. 이벤트 중재자 이벤트 큐에서 시작 이벤트를 받는다. 점대점 메시징으로 각각의 이벤트 채널로 처리 이벤트를 생성한다. 이벤트 프로세서 각 이벤트 프로세서는 이벤트 채널에서 이벤트를 받아 처리한다. 작업 완료후 중재자에게 응답한다. 장점 토폴로지의 단일 장애점(SPF, single point of failure)을 줄이고 전체 처리량과 성능을 높인다. 에러 처리와 오케스트레이션이 필요한 서비스는 중재자로 충분하다. 알맞은 중재자를 찾는 것이 중요하다. 아파치 카멜, 뮬, ESB, 스프링 인티그레이션 워크플로에 대해 잘 알고 있고 통제가 가능하다. 복구, 재시작이 가능하다.단점 이벤트 프로세서가 커플링된다 확장성이 낮다 성능이 낮다 내고장성이 좋지 않다 워크플로 모델링이 복잡하다두 토폴로지는 처리 이벤트의 의미와 사용 방법이 본질적으로 다르다.브로커 토폴로지 처리 이벤트 발행 후, 이벤트 프로세서는 각자 맡은 일을 하며 나머지 이벤트 프로세서는 액션에 반응한다.중재자 토폴로지 이벤트는 사건이 아니라 일어나야 할 일(커맨드)이다.비동기 통신이벤트 기반 아키텍처 스타일은 요청/응답 처리 및 파이어 엔드 포겟 처리까지 모두 비동기 통신만 사용한다.이는 시스템 응답성을 높일 수 있는 강점으로 활용된다.응답성과 성능 응답성 어떤 액션이 접수되어 곧 처리될 것을 유저에게 알림 성능 종단간 프로세스가 더 빨리 수행되게끔 만드는 것 에러 처리비동기 통신은 응답성을 개선하지만 에러 처리는 어려워 시스템의 복잡도가 증가한다.워크플로 이벤트 패턴을 사용하여 시스템 응답성에 영향을 미치지 않고 에러 처리를 개선할 수 있다. 이벤트 프로듀서는 메시지 채널을 통해 데이터를 이벤트 컨슈머에 비동기 전송한다. 이벤트 컨슈머가 데이터를 처리하는 도중 에러가 발생하면 즉시 해당 에러를 워크플로 프로세서에 위임한다. 이벤트 컨슈머는 다음 메시지로 넘어간다. (메시지 응답성) 이벤트를 수신한 워크플로 프로세서는 (사람의 개입 없이) 프로그래밍 방식으로 원데이터를 변경하여 긴급 조치한 후 원래 큐로 돌려보낸다. 문제점을 파악할 수 없는 경우 메시지를 다른 큐로 보내 대시보드가 받도록 한다. 이벤트 컨슈머는 이 메시지를 새로운 메시지로 간주, 재처리를 시도한다.주의해야할 점은 메시지의 순서가 변경된다는 점이다.한가지 해결 방법은 서비스가 에러가 발생한 번호를 붙여 큐에 담아 보관하는 것이다. 에러 조치되면 서비스는 큐에서 꺼내 처리한다." }, { "title": "그림으로 공부하는 마이크로서비스 구조 / 다루사와 히로유키 외 6명", "url": "/posts/book-msa-overview/", "categories": "Blogging, Book", "tags": "MSA", "date": "2023-01-15 11:45:00 +0900", "snippet": "그림으로 공부하는 마이크로서비스 구조마이크로서비스란 IaaS 이후 빨라진 인프라 구축 속도에 맞추어 애플리케이션 개발/운영을 신속하게 진행하기 위해 필요한 설계, 개발, 운영 기법을 모은 것.클라우드 네이티브 컴퓨팅컨테이너, 오케스트레이션, 마이크로서비스 개발/운영속도 향상 품질 개선 컨테이너와 오케스트레이션을 이용한 빠른 기반 구축 데브옵스는 인프라, 애플리케이션 배포를 자동화 빠른 개발, 테스트, 배포를 가능하게 하고, 자동화를 통해 조작 실수를 최소화하여 품질 향상에 기여 확장성(scalability) 고가용성(high availability) 오케스트레이션을 활용하여 클러스터를 쉽게 관리 하이브리드 클라우드 환경 구축 오케스트레이션이 제공하는 부하분산, 확장, 자가 복구 기능 활용 비용 절감 다른 클라우드 서비스 플랫폼으로 손쉽게 마이그레이션 가능 멀티 클라우드 환경 쉽게 구축 컨테이너서버 가상화리눅스 커널 기능을 이용해서 OS 수준의 가상 환경을 실현. 하나의 리눅스 OS상에 여러개의 가상 환경 호스팅. 각 가상환경 이미지가 OS를 가지고 있지 않아도 되므로 배포/실행이 빠르다컨테이너 오케스트레이션마이크로서비스 스타일로 설계한 경우 관리해야 할 클러스터 멤버가 늘어난다. 컨테이너 오케스트레이션은 컨테이너 클러스터의 관리/운영을 중심으로 컨테이너 클러스터 배포, name resolution, routing, service discovery, load balance, scalability, self-healing등의 기능을 제공한다. (컨테이너 애플리케이션의 생명주기 관리)데브옵스개발팀과 운영팀의 작업효율화IT 시스템 개발/릴리즈 속도 향상과 유연한 변경을 애플리케이션 개발/운영의 효율화 관점에서 실현개발팀과 운영팀의 연계를 위한 조직 혁신 : 데브옵스 연계를 위한 기법 : 애자일 개발 프로세스 원활한 연계를 위한 효율화 : CD 파이프라인마이크로서비스서비스(독립적으로 개발 및 실행되는 소프트웨어 컴포넌트)를 여러 개 조합해서 하나의 애플리케이션을 구축하는 소프트웨어 구조. 하나의 요청을 처리하기 위해 각 서비스는 REST나 메시징으로 통신하는 분산 컴퓨팅 환경을 구성한다.필요 기술: 컨테이너, 오케스트레이션, REST, 메시징 등필요 기법: 데브옵스, 애자일 개발 프로세스, CD, 도메인 주도 설계(Domain Driven Design)장점 애플리케이션을 작은 단위로, 단계적으로 릴리즈 및 변경할 수 있어 유연함 작은 단위로 scale-out, scale-in 가능하다는 관점에서 시스템 리소스를 최적 사용 서킷 브레이커와 조합해 장애 범위를 국소화단점 서비스간 통신 지연 우려 분산 배치된 DB간 일관성, 동기화 기법 필요 분산 컴퓨팅 환경의 운영 구조 정비 필요 시스템 전체의 설계 일관성 필요콘웨이 법칙(Cornway’s law): IT 시스템의 구조는 프로젝트 체제를 반영한다. 즉, 하나의 서비스를 개발, 운영할 때 하나의 팀이 담당한다.마이크로서비스는 대규모 비즈니스 도메인의 디지털 화, 100명 규모의 대규모 개발팀, 여러 시스템의 통합 등이 필요한 대규모 시스템 개발에 적합하다.마이크로서비스 아키텍처 변형레이어 아키텍처추상적인 것(애플리케이션)이 구체적인 것(인프라)에 의존 사용자 계층 사용자 인터페이스 구축 및 렌더링 요청/응답 전송 애플리케이션 계층 애플리케이션 조율 도메인 객체 접근 트랜잭션 관리 도메인 계층 도메인 상태와 동작(비즈니스 로직) 구현 인프라 계층 외부 리소스가 다른 계층에 접근할 수 있도록 지원(데이터, 메시징 접근) 장점 : 간단하고 이해하기 쉬움단점 : 확장성이 약하다. 추상적인 것이 구체적인 것에 의존하고 있어 인프라 구현이 변경될 경우 사용자 인터페이스나 애플리케이션에도 영향을 끼쳐 프로그램을 수정해야 한다.헥사거널 아키텍처레이어 아키텍처의 단점을 IoC로 보완하여 불특정 데이터 입출력에 대응하는 아키텍처.도메인을 중심으로, 그 주변에는 도메인을 호출하는 입력 측과 도메인에 의해 실행되는 출력측이 있다.외부 입출력과 도메인 사이의 ‘포트&amp;어댑터’어댑터는 외부 기능과 상호 작용하는 역할을 하며 외부 기능 단위로 교체할 수 있다. 그 예로 컨트롤러가 있다. 추상화 된 프로그래밍 인터페이스를 도메인에 제공하는 것이 포트이다(인터페이스). 포트를 사용해서 외부 기능에 접근하는 코드를 도메인 내에 구현해두면, 외부 기능을 변경해도 도메인은 영향 받지 않는다.마이크로서비스 트랜잭션 처리로컬 트랜잭션이란? 하나의 트랜잭션 컨텍스트내에서 처리 대상 리소스를 제한하는 것예를 들어 마이크로 서비스에서 하나의 서비스가 하나의 데이터베이스를 포함하고 트랜잭션 컨텍스트 내에서 해당 데이터베이스만 대상으로 하는 것.&lt;-&gt; 글로벌 트랜잭션이란? 하나의 트랜잭션 컨텍스트내에서 여러 리소스를 처리하는 것글로벌 트랜잭션은 마이크로서비스의 목표인 단순함, 두 컴포넌트 사이의 느슨한 결합을 방해하므로 지양해야 한다.데이터베이스간 동기화Saga 디자인 패턴분산 트랜잭션에서 마이크로 서비스 간 데이터 일관성을 관리하는 방법.첫번째 서비스가 첫번째 데이터베이스를 변경, 메시징 구조를 이용해 다음 서비스로 이벤트를 전달하여 로컬 트랜잭션을 릴레이로 연결한다.장애에 의해 서비스가 데이터베이스 변경에 실패한 경우 saga 패턴은 보상 트랜잭션을 실행한다. 트랜잭션 처리 결과를 원래대로 돌려놓기 위해 반대방향으로 처리하는 것이다.단점은 각 로컬 트랜잭션이 독립되어 있다 보니 특정 시점에는 데이터베이스 간 일관성이 유지 되지 않는다는 것이다.데이터 결합여러 데이터베이스에 나누어져 있는 데이터들을 하나의 View로 제공하려면 어떻게 해야 할까?API 컴포지션어플리케이션 계층에서 인메모리로 도메인 계층의 집약 서비스와 인프라 계층의 리포지터리 서비스를 통해 얻은 복수개의 데이터베이스들로 얻은 데이터를 결합장점 : 설계와 구현이 단순하다단점 : 애플리케이션에서 운영환경의 메모리 내에서 결합을 하게 되면 시스템 리소스에 부담을 주게된다.CQRS &amp; 이벤트 소싱CQRS(Command Query Relation Segregation, 명령 질의 책임 분리)데이터 접근 처리를 갱신형 처리(command, C,U,D)와 참조형 처리(질의, R)로 구분하고 각 독립된 서비스 컴포넌트와 데이터 저장소를 두는 디자인 패턴. 참조형 처리 : 일반적으로 요청량이 방대하며 빠른 응답을 필요로 한다. 갱신형 처리 : 요청량이 많지 않지만 안전하고 확실한 트랜잭션을 필요로 한다.이벤트 소싱갱신형 저장소와 참조형 저장소는 동기화되어야 한다.이벤트 소싱에서는 비즈니스 데이터를 분할하지 않고 모아서 하나의 데이터 저장소(event source)에 저장한다. 이벤트 소스는 대상 비즈니스에 대한 하나의 데이터 저장소이므로 글로벌 트랜잭션을 피할 수 있다.그러나 빠른 검색에는 적합하지 않다. 그래서 필요에 따라 메시징 기반 미들웨어의 비동기 메시징을 사용해 이벤트 소스와 검색용 데이터 저장소를 동기화한다. 이벤트 소스에 갱신 트랜잭션이 발생할 때 마다, 또는 이벤트 소스의 갱신 트랜잭션 수가 일정수에 도달하거나 일정 시간 간격으로 동기화하는 방법이 있다.장점: 쿼리 구현의 용이성 데이터 감시와 접근 제어 구현의 용이성 서비스 모델링과의 친화성 온라인 쇼핑의 발주 처리와 과거 주문 이력 검색 처리를 다른 컴포넌트로 분리할 수 있다. 단점: 기존 설계방식과 상이하기 때문에 적합한 사용처라는 것을 검증해야 한다.서비스 간 연계REST동기형 프로토콜이기 때문에 서비스 로직이 복잡하고 처리 완료까지 시간이 걸리는 처리에는 적합하지 않다. 응답 지연이 발생하고, 클라이언트 요청이 쌓이며 서버 리소스를 고갈시켜 장애를 발생시킬 수 있기 때문이다.메시징MOM(Messaging Oriented Middleware)을 통해서 생산자와 소비자가 메시지를 주고 받는 통신 모델. 단방향&amp;비동기형 요청/응답&amp;동기형 요청/응답&amp;비동기형마이크로 서비스에는 비동기 메시징을 사용해야 하는 경우가 자주 있다. (CQRS의 결과적 일관성, Saga)서비스화 진행 방법마이크로 서비스의 애플리케이션 개발/운영 기법 애자일 개발 프로세스 애플리케이션을 신속하게 단계적으로 릴리즈하는 것에 기여한다 콘웨이 법칙에 기반한 팀 체계 팀 규모를 작게 유지하고 비즈니스, IT 전문가들이 모두 같은 팀에 속하게 한다. DDD 도메인 모델을 설계 및 개발 작업의 중심에 두고 반복적으로 변경 및 진화시켜 프로그램 구현으로 이어지게 하자 유비쿼터스 언어 : 팀 멤버가 오해없이 커뮤니케이션하기 위해 만드는 공통 용어집 큰 단위로 시작하자세분화 정도나 경계가 있는 컨텍스트가 최적화되어있는지는 시스템 운영 직전에 알 수 없다. 따라서 모노리스 우선으로 개발해서 필요에 따라 서비스화를 진행하자.세션 정보 유지여러 방면에서 처리 상태를 유지해야 하는 경우, 세션 영구화 처리 중인 상태를 데이터베이스 등의 영구적 데이터 저장소에 저장 스티키 세션 처리 상태가 저장되어 있는 서버에 클라이언트 요청을 전송 쿠버네티스의 Ingress가 세션 어피니티 기능 제공 상태의 서비스화 기법 상태를 유지하기 위한 서비스를 신설하고 데이터베이스 등의 영구 저장소에 저장한다 ex) 장바구니 서비스 마이그레이션 기간 중의 의존관계시스템 개선에 마이크로서비스를 이용할 경우 신규 서비스가 기존 모노리스에 의존하지 않게 하자. 반대는 괜찮다. 기존 모노리스가 미래에 신규 서비스로 교체되거나 파기될 수 있기 때문.마이크로서비스 패턴데이터 관리 : 데이터베이스 배치 모델분산 데이터베이스에서 데이터 접근 모델을 설계하려면 아래 과제들을 해결해야 한다. 데이터베이스 배치 모델 데이터 동기화 데이터 결합 API 컴포지션, CQRS&amp;이벤트 소싱 서비스별 데이터베이스 패턴 데이터베이스 인스턴스를 서비스 단위로 작성/운영한다. 장점 : 유연하고 빠르게 애플리케이션, 데이터베이스 제품 및 기술을 유연하게 선택 가능 고려 사항 결과 일관성이 허용되는지 분산 트랜잭션을 권장하지 않으므로 데이터간 동기화 구조 사가 패턴 이용 여러 데이터베이스에 걸쳐있는 데이터를 검색 및 집약하는 구조 API 컴포지션, CQRS&amp;이벤트 소싱 공유 데이터베이스 패턴 결과 일관성이 허용되지 않는 경우 통합된 하나의 데이터베이스 인스턴스를 복수의 서비스 및 애플리케이션, 시스템이 공유할 수 있는 데이터베이스 배치 패턴 장점 로컬 트랜잭션을 사용한 ACID 특성을 유지하고 데이터 일관성 확보 단점 애플리케이션과 데이터베이스를 신속하고 유연하게 변경하는 것이 어렵다 단일 데이터베이스에 처리가 집중된다 비관적 락(pessimistic locking)을 건 후 변경을 처리해야 해서 순차적으로 처리해야 한다 사가 패턴 로컬 트랜잭션 이벤트와 보상 트랜잭션을 활용하여 여러 데이터베이스에 걸쳐 있는 데이터를 동기화하는 기법 구현 기법 코레오그래피(choreography) 각 서비스가 자립적으로 메시지 제품상에서 데이터를 동기화. 이벤트를 이용해 로컬 트랜잭션과 보상 트랜잭션 흐름을 제어한다. 장점 : 구조가 단순하다 고려사항 각 서비스 내부에는 서비스 간 연계 흐름 제어 로직이 구현되어 있으므로 사가 전체를 파악하기 어렵다 트랜잭션 실행 시의 진행 상태 확인이나 추적이 어렵다 관심사 분리가 저해됨 비즈니스 로직을 구현해야할 서비스 내부에 사가 제어 로직이 들어가기 때문 오케스트레이션 사가 오케스트레이터가 트랜잭션 처리를 조율한다 장점 : 서비스의 역할분담이 명확하다 각 서비스와 DB의 연계 파악이 쉽다 (프로세스 진행 상황을 파악하기 쉽다) 고려사항 오케스트레이터가 무거워지지 않도록 역할분담에 유의해야한다 트랜잭션 메시징서비스 내의 데이터베이스와 메시징 간 일관성트랜잭셔널 아웃박스 패턴 트랜잭셔널 아웃박스 : 비즈니스 데이터를 저장하는 데이터베이스와 동일한 데이터베이스 내에 테이블을 만들어, 비즈니스 데이터 처리를 통지하는 이벤트 정보를 저장 및 공유할 때 사용한다. 비즈니스 데이터와 로컬 트랜잭션으로 동기화폴링 퍼블리셔 패턴 아웃박스 테이블을 읽는 메시지 릴레이가 아웃박스 테이블을 폴링 장점 : 애플리케이션으로 구현이 쉽다. 고려할 점 : 퍼블리셔는 사용자가 정의한 아웃박스 테이블에 의존하므로 아웃박스 테이블 유지/관리도 고려해야한다.트랜잭션 로그 테일링 패턴 서비스가 로컬 트랜잭션을 이용해 업무 테이블을 갱신함과 동시에 처리내용을 DBMS가 제공하는 트랜잭션 로그에 기록. 트랜잭션 로그 마이너는 트랜잭션 로그에 기록된 로그 엔트리를 취득하여 MOM에 발행한다. 장점 : 아웃박스 테이블 유지/관리할 필요가 없다. DBMS가 제공하는 트랜잭션 로그를 사용하기 때문 고려할 점 : 데이터베이스 제품마다 트랜잭션 로그 사양이 다르기 때문에 제품 단위별로 트랜잭션 로그 마이너를 구현해야한다.서비스 검색서비스 배포 시마다 도메인명과 IP 주소가 변경될 위험이 있다. 클라이언트는 서비스 호출 이전에 서비스의 정확한 주소를 파악해야 한다.클라이언트 측 검색(client-side discovery) 서비스의 주소 파악을 클라이언트가 한다.서버 측 검색(server-side discovery) 서비스의 주소를 서버측 컴포넌트에 위임한다. 업무 프로그램과 분리된 컴포넌트이며, 애플리케이션 코드 구현 없이 외부장치로 구현할 수 있다. 부하분산기, 프록시 등 서비스 레지스트리 패턴 마이크로서비스에서 서비스명을 해석하는 컴포넌트. 서비스명 해석을 위한 영구 데이터 저장소자가 등록 패턴(self registration) 배포 시에 서비스가 자신의 도메인 명과 주소 정보를 매핑한 위치정보를 서비스 레지스트리에 등록하는 패턴 장점 : 애플리케이션 로직으로 등록 처리를 구현해, 모든 요건에 유연하게 대응할 수 있다 고려할 점 : 서비스 헬스 체크나 장애 발생 시 복구처리에 대한 유지/관리 필요외부자 등록 패턴(3rd-party registration) 서비스 레지스트리 위치 정보 등록을 3rd party에게 위임하는 패턴 쿠버네티스같은 오케스트레이션 프레임워크에게 위임 장점 : 정보 등록 작업을 줄여줄 수 있다외부 API마이크로서비스에서 클라이언트와 서비스 연동 시에 발생하는 문제들을 해결한다.API Gateway 패턴 도메인 경계에 클라이언트 처리를 담당하는 전용 API 게이트웨이를 배치하는 것 클라이언트와 서비스 간에 목적 단위로 전용 API 게이트웨이를 배치하여 애플리케이션의 조율, 트랜잭션 제어 등의 처리를 구현한다 도메인 주도 설계의 애플리케이션 서비스, GoF 디자인 패턴의 파사드에 해당한다 장점 : 클라이언트와 서비스간 호출 횟수를 줄여 네트워크 지연 최소화 서비스측 변경 시에도 API 게이트웨이가 완충하여 클라이언트 측 영향을 최소화한다. 인터넷과 인트라넷 간 통신 프로토콜 교환을 담당할 수 있다. 고려할 점 : 특별한 요건이 없는, 인증과 허가, 로그, 메트릭스, 부하분산, 캐시 등 비기능 요건을 API 게이트웨이 제품 사용이 아닌 사용자 애플리케이션으로 구현하는 것은 시간 낭비다. 프론트엔드용 백엔드 패턴(BFF, Backends For Frontend) 클라이언트 종류별로 게이트웨이 처리를 적용한다 장점 : 다양한 클라이언트 종류를 지원한다. 특정 클라이언트에 대해 게이트웨이 처리 로직을 변경해야 하는 경우 다른 클라이언트가 영향을 받지 않도록 한다. API 게이트웨이와 클라이언트 고유의 게이트웨이 기능을 분할할 수 있다. 통신REST 프로토콜의 경우 요청/응답 및 동기형 통신 고유의 다양한 문제점들이 있다. 클라이언트와 서비스, 서비스간 연동을 최적화하기 위해 REST 프로토콜의 문제점을 해결하는 프로토콜을 살펴보자.원격 프로시저 호출 패턴(RPI, Remote Procedure Invocation) 요청/응답 및 동기형 통신 REST가 대표적인 구현 장점 : 쉽고 간단하고 범용적 고려할 점: 확장성이 약하다 복잡하고 시간이 오래 걸리는 처리에 적합하지 않다 지연이 있으면 응답 연장, 클라이언트 요청이 쌓이며 서버 리소스가 고갈된다 메시징 패턴 비동기적 통신. 발행자와 구독자가 이벤트를 통해 통신하는 모델. MOM 또는 메시지 브로커를 통해 이벤트나 메시지를 비동기적으로 전달한다. 발행자가 이벤트를 생성할 때 구독자를 항상 실행할 필요가 없으며, 구독자가 원할 때 MOM 토픽에 저장되어있는 이벤트를 가져올 수 있다. 일방향&amp;비동기형, 요청/응답&amp;동기형, 요청/응답&amp;비동기형 세가지 통신 사용 가능도메인 특화 프로토콜 패턴(domain-specific protocol) 특정 상황에 맞는 프로토콜을 적용하는 패턴 메일 발신 - SMTP 메일 수신 - POP, IMAP 멱등 소비자 패턴(idempotent consumer) 의도하지 않은 작업에 멱등성을 보장하는 통신 패턴 작업 단위별 고유 ID를 할당해 같은 작업의 중복 실행을 방지한다 배포호스트별 다중 서비스 인스턴스(multiple service instance per host) 한대의 호스트에서 다중 서비스를 실행하는 모델 장점 : 호스트 관리가 용이하다 하나의 가상 머신에서 여러 서비스를 실행해 전체 리소스를 줄일 수 있다 고려할 점 : 모니터링과 장애 관리 관점에서 개별 서비스의 상태를 확인하기 어렵다 특정 서비스에 큰 부하가 걸린 경우, 다른 서비스가 사용할 수 있는 리소스가 줄어들어 성능에 영향을 끼칠 수 있다 한대의 호스트가 단일 장애 지점이 되므로 서비스 전체에 영향을 줄 수 있다 여러 서비스들이 의존 관계에 있는 경우, 배포나 확장성 설계가 복잡해진다 호스트별 단일 서비스 인스턴스 호스트마다 하나의 서비스를 가지는 모델 장점 : 장애 관리 효율이 높다. 특정 호스트가 정지되어도 다른 서비스들은 영향을 받지 않으므로 독립적으로 서비스 확장이 가능하다 고려할 점 : 호스트 수가 늘어나면 비용도 함께 늘어난다 VM별 서비스 인스턴스 배포 대상으로 하이퍼바이저형 가상 머신(하드웨어 수준의 가상화)을 사용하는 패턴 서비스 수가 적은 애플리케이션에서는 컨테이너 가상화 기반보다 적은 비용으로 쉽게 배포할 수 있는 경우가 있다 장점 : 서비스 인스턴스를 패키지화할 수 있다 하나의 가상 머신 이미지로 서비스 인스턴스 실행에 필요한 OS, 각종 미들웨어, 애플리케이션 설치, 설정, 검증 완료된 상태로 패키지화하여 배포가 용이해진다. 배포 시기를 단축한다 서비스 인스턴스를 분리할 수 있다 서비스 인스턴스 성능을 독립된 형태로 유지할 수 있다. 각 가상 머신 리소스를 고정해서 할당할 수 있으므로 단점 : 배포에 시간이 걸린다 가상머신은 OS를 포함하고 있어서 이미지 사이즈가 커진다 리소스 사용법이 비효율적이다 시스템 관리 비용이 높아진다 컨테이너별 서비스 인스턴스 컨테이너(OS 수준의 가상화 기술)를 사용해 서비스 인스턴스를 구성하는 패턴 장점 : 배포 속도가 빠르다 리소스 효율이 높다 컨테이너들이 호스트 OS의 커널을 공유 이동성이 좋다 단점 컨테이너 기반 구축 운영이 쉽지 않다 구축한 컨테이너 기반을 계속 운영하는 Day2 작업이 필요 오케스트레이션 자체의 보수나 컨테이너가 실행되는 워커 노드 자체의 유지/관리가 필요하다 서버리스 배포 퍼블릭 클라우드가 제공하는 서버리스 서비스를 사용해 서비스를 배포하는 패턴 HTTP를 사용하는 웹앱이나 모바일 앱에서 이벤트나 호출을 받으면 서버리스 서비스를 사용해서 애플리케이션 로직을 실행 장점 : OS와 런타임 유지/관리가 불필요해서 애플리케이션 개발에 집중할 수 있다 서비스 부하에 따라 자동으로 확장/축소 된다 서비스 요청량을 기준으로 과금된다 단점 지연이 발생한다 애플리케이션 인스턴스를 프로비저닝하므로 애플리케이션 실행까지의 시간이 걸린다 이벤트/요청 기반의 프로그래밍 모델로 제한된다 기본적으로 지연 시간 때문에 이벤트/요청 기반의 서비스에만 사용이 가능하다. 관찰 가능성(observability, 가시성)마이크로서비스의 논리적 물리적으로 분산 배치된 각 서비스와 관련 컴포넌트를 어떻게 빠짐없이 감시할 수 있을까?분산 추적 각 요청 또는 이벤트 단위로 고유 ID를 할당하고 로그나 트레이스에 기록하는 패턴 처리 상황과 장애 원인을 추적하게 쉽게 한다 로그 통합 마이크로서비스와 같은 분산 컴퓨팅 환경에서의 로그 분산 문제를 해결하기 위해 로그를 한곳에 모으는 패턴 Stslog, Fluentd 예외 추적(exception tracking) 예외를 관리해서 운영 담당자에게 통지하는 패턴 사전에 설정한 키워드를 포함하는 로그를 감지한 경우, 운영담당자에게 알린다 애플리케이션 매트릭스 CPU 사용률과 메모리 등 시스템 리소스 사용 상태, 처리수와 응답시간 등의 메트릭 수집해서 감시하는 패턴 오케스트레이션 프레임워크에서 분산 배치된 서비스의 확장을 관리하기 위해 애플리케이션 런타임 상태를 파악한다 audit logging 마이크로서비스의 사용자 활동 통계와 분석을 목적으로 하는 패턴 문제 발생 시 지원, 문제 재현을 통한 분석에 사용 보안 방어, 기업 규정 위반 확인에 사용 audit log와 함께 마이크로 세그멘테이션에 의한 제로 트러스트와 같은 대책이 사용된다 health check API 패턴 각 서비스의 호출 가능 상태를 파악하는 패턴 감시 주체 라우팅이나 부하분산을 담당하는 컴포넌트가 담당 서비스 레지스트리가 담당 서비스 레지스트리가 서비스의 각 인스턴스 상태에 따라 클라이언트나 라우터에 반환하는 서버 주소를 변경 클라이언트는 정상적으로 실행되고 있는 서비스 인스턴스로 요청을 전달할 수 있다 리팩터링개발이 끝난 시스템을 클라우드 네이티브 애플리케이션으로 마이그레이션할 때부패방지 계층(anti-corruption layer) 서비스와 모노리스 연계 시 통신 프로토콜 또는 애플리케이션 프로토콜 차이를 해결하기 위해 어댑터를 두는 패턴 서비스가 모노리스에 의존하지 않고 양쪽을 연계한다 스트랭글러 애플리케이션(strangler application) SOE(System of Engagement)와 클라이언트의 경계인 스트랭글러 포드(strangler pod)를 개발 및 배치한다. 각 단계의 마이그레이션이 끝나면 애플리케이션 요청이 마이크로서비스화된 서비스로 라우팅 되도록 스트랭글러 포드의 메뉴 아이템이 가리키는 URI를 변경한다. 장점 : 마이그레이션 작업 후 바로 서비스를 릴리즈한다 사용자가 서비스를 빠르게 접할 수 있도록 함 경영진에게도 구체적인 성과를 보여주는데 효과적 신규 릴리즈한 클라우드 네이티브 애플리케이션에서 장애 발생시 모노리스로 다시 되돌리기 쉽다 스트랭글러 포드상의 메뉴 아이템 URI를 변경 작업을 단계적으로 진행 가능 서비스 메시서비스 간 상호 통신이 그물 형태로 연결되어 있어서 마이크로 서비스 간 통신을 관리해주는 구조 서비스 메시는 control plain, data plain 두개의 컴포넌트로 구성 control plain : 서비스 메시를 관리 서비스 검색 등 관리에 필요한 정보 보관하거나 구성 변경 등의 관리 명령을 내린다. data plain : control plain이 내린 지시를 받아 서비스 통신을 제어하거나 관리에 필요한 정보를 control plain에 전송한다. 서비스 구현에 내장되는 것이 아니라 별도의 컴포넌트로 배포 (사이드카 패턴) 서비스 메시로 할 수 있는 것 서비스 검색과 부하 분산 트래픽 제어 서킷 브레이커 분산 추적을 위한 원격 측정 데이터 수집 보안 서비스 검색과 부하 분산 각 서비스가 배포나 재시작 시에 IP주소가 변경되면 data plain이 IP주소를 control plain에 통지한다. control plain은 각 서비스의 주소를 관리한다. 서비스에 접근하는 쪽의 data plain은 control plain에서 접근할 서비스의 주소 정보를 입수한다.트래픽 제어서비스에 접속을 할당하기 위한 설정을 변경하거나 서비스가 반환하는 값을 변경하는 드으이 서비스간 통신을 제어할 수 있다. data plain이 요청을 control plain에 전달 control plain은 요청에 따라 다음과 같은 제어가 가능하다 트래픽 분할 : 요청 접속 위치를 비율로 나눈다 조건에 따른 트래픽 분리 : 요청 내용 관련 조건을 설정해 접속 위치를 변경 장애 주입 : 장애 상태를 만들어 효과적으로 테스트 할 수 있다 data plain이 실행서킷 브레이커특정 서비스에 장애가 발생했을 때 영향 범위를 최소화 하기 위한 도구 장애발생을 감지해 일정시간 장애가 발생한 서비스 접근을 절단, 서비스 호출 측에 오류를 바로 반환한다 타임아웃 대기를 배제하여 시스템 전체 지연을 방지 서비스 회복을 감지하면 해당 서비스 접근을 원래대로 복구한다분산 추적을 위한 원격 측정 데이터 수집하나의 요청이 여러 서비스에서 사용될 때 호출되는 순서나 각 서비스에서의 처리 시간 등 요청을 추적하는 구조보안서비스 메시는 서비스가 다른 서비스를 호출할 때 인증 및 허가 등의 보안 기능을 제공한다. control plain은 data plain에 인증 및 허가 방침을 배포한다 control plain은 data plain에 전자 인증서를 배포한다 서비스 호출 측과 호출되는 서비스 측이 상호 TLS 인증으로 통신할 수 있다" }, { "title": "Extreme Programming / Kent Beck", "url": "/posts/book-extreme-programming/", "categories": "Blogging, Book", "tags": "Agile", "date": "2023-01-02 12:08:00 +0900", "snippet": "Extreme Programming(XP)는 무엇인가 XP는 Agile 프레임워크 중 하나, 소프트웨어 개발의 제약 조건들을 다루는 것에 바탕을 둔 방법론 방법론이란 ‘성공을 보장하려면 따라야 하는 규칙들의 집합’으로 해석되지만, XP는 팀마다 적용 방식이 다를 수 있고 XP를 적용하여도 성공 수준이 모두 다르다 양질의 소프트웨어를 만들어내고, 모호하거나 빠른 속도로 변하는 요구사항에 적응할 수 있게 한다1999년 켄트벡이 좋은 소프트웨어 팀들이 공통으로 지닌 것들 중 가장 효과가 좋았던 것들을 엮어서 가장 순수하고, 가장 Extreme 한 모범 사례를 추출하였다(Extreme Programming Explained, October 1999). 그러나 현재에는 꽤 일반적인 것들이며 XP의 정의는 계속해서 확장되고 있다.운전하는 법 그리고 XP운전은 차를 바른 방향으로 가도록 맞춰두고 그대로 있는게 아니다.계속 신경쓰면서 조금씩 방향을 고치는 것이다.XP 차원에서의 적용 소프트웨어 deploy 간격을 짧게 유지하여 변화하는 고객의 시스템 내용 방향과 개발 팀의 개발 프로세스에 대응한다. 고객은 소프트웨어가 어디로 갈지 매주 결정을 내리면서, 어느 지점이 목표 지점인지 늘 생각해야 한다.XP 배우기 : 가치, 원칙, 실천방법https://lh4.googleusercontent.com/hmcLOvegici6sMdr9VSDuRBc914cY9QbmPTFPXhNESHAdFbABCPdR1x6NF1JErMs0ZweCrNknBDyedyTLRyA96L0ahC-93dzsn_mCDNhTtaw8RDVJ3OKPK4FHPc_hvmN1xtXVkiqL1P_hVCvbn2ESQY_y0oWES5Zmg5cCe0rTPxZHb4iFROUBM8lxYYXHg 가치 자체로는 추상적이고 모호하나 실천방법에 목적을 부여한다 실천방법 구체적이고 현실적인 방안 가치에 책임을 부여한다 그러나 어떤 상황이냐에 따라 완전히 달라진다 원칙 가치와 실천방법 사이를 잇는 다리 특정 영역에서 영원한 지침 가치 의사소통 개발 과정에서 문제가 생겼을 때 누군가는 이미 해결책을 알고 있는 경우가 많다 한 팀이라는 느낌을 주고 효과적으로 협동하려면 의사소통이 중요하다 단순성 제대로 동작할만한 가장 단순한 것 불필요한 복잡성을 제거하자 피드백 한번에 완벽하게 문제를 해결할 수는 없다 처음 보는 문제에 대해 어떻게 하는 것이 제대로 하는것인지 아직 모를 수 있다 우리의 통제능력과 예측능력을 벗어나는 변화로 이전 결정이 무효가 될 수 있다 해결책을 구현하는 도중 시간이 지나 상황이 바뀌어 그 해결책이 무효가 될 수 있다 피드백을 통해 목표에 나아간다 용기 용기만으로는 위험하지만 다른 가치들과 조화를 이룰 때 강력해진다 의사소통 + 신뢰 : 진실을 말할 수 있는 용기 단순성 : 실패할 해결책을 버리고 새로운 해결책을 찾아 나서는 용기 피드백 : 구체적인 답변을 추구하는 용기 존중 팀에 속한 모든 개인의 기여를 존중하자 원칙인간성, 경제성, 상호 이익, 자기 유사성, 개선, 다양성, 반성, 흐름, 기회, 잉여, 실패, 품질, 아기발걸음, 받아들인 책임… 상호 이익 모든 활동은 그 활동과 관련된 모든 사람에게 이익이 되어야만 한다 (win-win-win) 원활한 인간관계를 유지해야하기 때문 따라서 소프트웨어 내부에 대한 설명 문서를 대량으로 작성하는것은 원칙에 위배된다 미래 프로그래머들이 혹시 코드를 유지보수할 수 있으니 그것을 쉽게 해주기 위해 현재의 내 개발속도를 현저히 떨어뜨리는 것 해결방법 : ‘미래와 의사소통하기’ 나는 자동화 테스트를 짜며 더 나은 설계와 구현을 얻을 수 있다. 그리고 그 테스트들은 미래의 프로그래머들도 사용할 수 있게 남겨둔다. 이러한 실천방법은 나와 미래의 유지보수자 모두에게 이익이 된다. 아기발걸음 중요한 변화를 한번에 시도하는 것은 위험하다 작은 단계를 빠르게 밟아 도약하자 단계를 쪼갤때 생기는 부하 &lt; 큰 변화를 시도했다가 실패해서 rollback때 드는 낭비 실천방법 : TDD, 지속적 통합 실천방법함께 앉기, 전체 팀, 정보를 제공하는 작업 공간, 활기찬 작업, 짝 프로그래밍, 스토리, 일주일별 주기, 분기별 주기, 여유, 10분 빌드, 지속적 통합, TDD, 점진적 설계… 10분 빌드 10분만에 자동으로 전체 시스템을 빌드하고 모든 테스트를 돌려라 10분 이상일 경우 실행하는 횟수가 현격히 줄어들며 피드백을 받을 기회를 놓치게 된다 모든 테스트를 실행시켜 추측으로 인한 위험을 제거한다 스트레스 수준이 높아질 경우의 수동 빌드 빈도가 줄어들 수 있기 때문에 자동화된 빌드가 훨씬 가치있다 지속적 통합 변경한 것을 두세 시간만에 통합하고 테스트하라 통합을 오래 미룰수록 비용이 더 들며 통합 비용을 예측하기도 어렵다 저자는 동기적으로 프로그래밍 에피소드가 하나 끝날때마다 페어와 함께 통합 빌드가 완료되고 전체 테스트 스위트가 돌아가는 것을 기다리며 페어 프로그래밍 리뷰 비동기적 방식일 경우 컨텍스트 전환으로 인한 시간 낭비 존재 TDD 명시적이고 객관적이게 이 프로그램이 무엇을 해야하는지 나타낸다 테스트하기 쉬운 결합도가 낮고 응집도가 높은 코드를 만들어 낸다 작동하는 깨끗한 코드를 작성하고, 테스트로 의도를 드러내면 팀원들의 신뢰를 얻을 수 있다 테스트 작성-코드 작성-리팩토링 과정이 리듬으로 발전해 일의 과정이 자연스럽고 효율적 점진적 설계 중요한 결정은 초기에 내리고, 규모가 작은 결정은 나중으로 미룬다 설계를 사용하는 시점과 가까울 때 설계하는 것이 효율적이기 때문 작은 보폭(아기 발걸음)으로 변경을 주는 것에 익숙해지면, 시스템이 더 단순해지고, 테스트도 작성하기 쉬워지며, 시스템이 더 작아져 팀에서 의사소통해야 할 정보도 적어진다. 활기찬 작업 생산성은 업무 시간에 비례하지 않는다. 최상의 컨디션을 유지하자. 근무시간 개선을 위해 날마다 통째로 두 시간을 방해받지 않는 코딩 시간으로 선언하는 방법도 있다 XP 적용하기조직을 변화하는 방법은 자신부터 변화를 시작하는 것이다 자기 기술을 발전시킨 다음, 그 기술로 다른 사람을 도우라 스스로 시도하고 싶지 않은 일을 다른 사람이 하기를 기대하는 것은 인간관계에 해를 끼치고 팀의 응집성을 파괴한다 지속적 개선 지속적인 깨어있음 -&gt; 피드백 수용하기 -&gt; 개선에 대해 열린 마음 코치 고르기 XP 적용은 지도력이 필요하다 코치는 XP의 가치, 원칙, 실천방법을 예를 통해 전달하여 학습속도를 끌어올릴 수 있다References [익스트림 프로그래밍 2판 - 켄트 벡, 신시아 안드레스 공저 / 김창준, 정지호 공역 인사이트(insight)](http://www.yes24.com/Product/Goods/2126201) " }, { "title": "AWS Docs", "url": "/posts/aws-docs/", "categories": "Blogging, Network", "tags": "AWS", "date": "2022-10-24 11:46:00 +0900", "snippet": "AWS DocsAmazon EC2(Elastic Compute Cloud) AWS 클라우드에서 확장 가능 컴퓨팅 용량을 제공 EC2를 생성할 경우 다음의 기능을 제공한다 인스턴스 : 가상 컴퓨팅 환경 VPC(Virtual Private Cloud) 기본 보안 그룹 Amazon 머신 이미지(AMI) EBS(Elastic Block Store) 등… VPC(Virtual Private Cloud) AWS 클라우드에서 논리적으로 분리된 가상 네트워크 생성시 IPv4 주소 범위를 CIDR(Classless Inter-Domain Routing) 블록형태로 지정해야 한다CIDR(Classless Inter-Domain Routing) 블록 IP 대역을 표기하는 방식 ex) 192.168.0.0/16 = 192.168.0.0 ~ 2^(32-16) + 192.168.0.0 = 192.168.255.255Subnet VPC의 IP주소 범위 VPC 내에서 지정된 서브넷으로 AWS 리소스를 시작 가능하다 (가용존) 퍼블릭 서브넷 : 인터넷에 연결되어야 하는 리소스에 사용 프라이빗 서브넷: 인터넷에 연결되지 않는 리소스에 사용. 퍼블릭 인터넷에 액세스하려면 NAT 장치가 필요RoutingTable 각 서브넷은 서브넷 외부로 나가는 아웃바운드 트래픽에 대해 허용된 경로를 지정하는 Routing Table에 연결되어 있어야 한다Network ACL(Access Control List) 서브넷 수준에서 네트워크 접근을 제어 즉 연결된 서브넷에서 배포된 모든 인스턴스에 적용 특정 인바운드 또는 아웃바운드 트래픽을 허용하거나 거부Security Group 인스턴스 레벨에서 운영되는 트래픽 제어 인스턴스와 연결하면 인스턴스에 대한 인바운드 및 아웃바운드 트래픽 제어다른 네트워크에 VPC 연결 VPC를 다른 VPC 혹은 인터넷 또는 온프레미스 네트워크에 연결할 수 있다.Internet Gateway VPC 구성 요소로, VPC와 인터넷이 통신할 수 있게 해준다 서브넷의 Internet Gateway로 향하는 라우팅의 유무로 퍼블릭 서브넷과 프라이빗 서브넷을 구분할 수 있다 사용을 위해 인스턴스에 탄력적 IP(Elastic IP) 주소를 할당해야 한다탄력적 IP 주소 동적 클라우드 컴퓨팅을 위해 고안된 고정 퍼블릭 IPv4 주소 인스턴스의 오류가 있을 경우, 다른 인스턴스의 주소를 신속하게 다시 매핑하여 오류를 감출 수 있다NAT Gateway NAT(Network address translation) : 네트워크 주소 변환 서비스 정보를 전송하기 전 여러 로컬 개인 주소를 공용 주소로 매핑하는 방법 프라이빗 서브넷의 인스턴스가 인터넷 접근 가능하게 한다" }, { "title": "Effective Java - 2장. 객체 생성과 파괴", "url": "/posts/book-effective-java-1/", "categories": "Blogging, Book", "tags": "JAVA", "date": "2022-09-12 01:39:00 +0900", "snippet": "ITEM 1 - 생성자 대신 정적 팩토리 메서드를 고려하라클래스는 클라이언트에 public 생성자 대신 정적 팩토리 메서드를 제공할 수 있다.정적 팩토리 메서드 - 객체 생성을 하는 정적(static) 메서드이런 경우 5가지 장점이 있다. 이름을 가질 수 있다 하나의 시그니처로는 하나의 생성자만 만들 수 있다. 의미가 명확하게 드러나는 이름으로 반환될 객체의 특성을 제대로 설명할 수 있다. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다 불변 클래스는 인스턴스를 미리 만들어 놓거나 새로 생성한 인스턴스를 캐싱하여 재활용할 수 있으므로 불필요한 객체 생성을 막을 수 있다. 정적 팩토리 방식의, 언제 어떤 인스턴스가 살아있게 할 지 통제하는 클래스를 인스턴스 통제(instance-controlled) 클래스라고 한다. 인스턴스를 통제하면 클래스를 싱글턴으로 만들 수도, 인스턴스화 불가로 만들 수도 있다. 또한 불변 값 클래스에서 동치인 인스턴스가 단 하나뿐임을 보장할 수도 있다. 반환 타입의 하위 타입 객체를 반환할 수 있다 구현 클래스를 공개하지 않고도 객체를 반환할 수 있어 API를 작게 만들 수 있다는 장점이 있다. ex) java.util.Collections 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다 클라이언트는 팩토리가 건네주는 객체가 어떤 클래스의 인스턴스인지 알 수도, 알 필요도 없기에 유연하게 구현할 수 있다. 정적 팩토리 메소드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다 클라이언트가 서비스의 인스턴스를 얻을 때 사용하는 서비스 접근 API 역시 정적 팩토리이다. 서비스 제공자 인터페이스가 없다면 각 구현체를 인스턴스로 만들 때 리플렉션을 사용해야 한다. 단점은 다음과 같다. 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다. 정적 팩토리 메서드는 프로그래머가 찾기 어렵다. 이러한 문제를 해결하기 위해 흔히 사용하는 명명 방식들은 from : 하나의 매개변수를 받아 객체를 생성 (형변환) of : 여러개의 매개변수를 받아 객체를 생성 valueOf : from과 of의 더 자세한 버전 instance getInstance : 인스턴스를 생성하지만, 같은 인스턴스임은 보장하지 않는다 create newInstance : 새로운 인스턴스 생성 등이 있다. ITEM 2 - 생성자에 매개변수가 많다면 빌더를 고려하라정적 팩터리와 생성자는 선택적 매개변수가 많을 때 대응하기 어렵다점층적 생성자 패턴(telescoping constructor pattern)public class NutritionFacts {\tprivate final int calories; // 필수\tprivate final int fat; // 선택\tprivate final int sodium; // 선택\tprivate final int carbonhydrate; // 선택\tpublic NutritionFacts(int calories) {\t\tthis(calories, 0);\t}\tpublic NutritionFacts(int calories, int fat) {\t\tthis(calories, fat, 0);\t}...\tpublic NutritionFacts(int calories, int fat, int sodium, int carbonhydrate) {\t\tthis.calories = calories;\t\tthis.fat = fat;\t\tthis.sodium = sodium;\t\tthis.carbonhydrate = carbonhydrate;\t}}필수 매개변수만 받는 생성자, 필수 매개변수 1개와 선택 매개변수 1개를 받는 생성자 … 전부 다 받는 생성자로 늘려나가는 형태. 인스턴스를 만들려면 원하는 매개변수를 포함하는 가장 짧은 생성자를 사용하면 된다.선택 매개변수의 수가 많아지면 읽기도 어렵고, 코드를 작성하기도 어렵다.자바빈즈 패턴(JavaBeans pattern)매개변수가 없는 생성자로 객체를 만들고, setter 메서드를 통해 매개변수의 값을 설정한다public class NutritionFacts {\tprivate final int calories = 0 // 필수\tprivate final int fat = 0 // 선택\tprivate final int sodium = 0 // 선택\tprivate final int carbonhydrate = 0 // 선택\tpublic NutritionFacts() { }\tpublic void setCalories(int val) { calories = val; }\tpublic void setFat(int val) { fat = val; }\tpublic void setSodium(int val) { sodium = val; }\tpublic void setCarbonhydrate(int val) { carbonhydrate = val; }}코드가 길지만 점층적 생성자 패턴에 비해 더 읽기 쉽고 인스턴스를 만들기도 쉽다.그러나 심각한 단점을 가지고 있다. 객체를 하나 만드려면 여러 setter를 호출해야 하고, 객체가 완전히 생성되기 이전에는 일관성(consistency)이 무너진 상태에 놓이게 된다(오히려 일관성 면에서는 점층적 생성자 패턴이 유리하다). 일관성이 깨진 객체는 버그를 심은 코드와 그 버그 때문에 런타임에 문제를 겪는 코드가 물리적으로 멀 것이므로 디버깅이 어렵다. 클래스를 불변으로 만들 수도 없으므로 스레드 안전성을 위해 프로그래머의 추가 작업이 필요하다.빌더 패턴(Builder pattern)스레드 안전성과 가독성을 지키는 방법이다.public class NutritionFacts {\tprivate final int calories; // 필수\tprivate final int fat; // 선택\tprivate final int sodium; // 선택\tprivate final int carbonhydrate; // 선택\tpublic static class Builder {\t // 필수 매개변수\t private final int calories;\t // 선택 매개변수 - 기본값으로 초기화\t private final int fat = 0;\t\tprivate final int sodium = 0;\t\tprivate final int carbonhydrate = 0;\t public Builder(int calories) {\t this.calories = calories;\t }\t public Builder fat(int val) {\t fat = val;\t return this;\t }\t public Builder sodium(int val) {\t sodium = val;\t return this;\t }\t public Builder carbonhydrate(int val) {\t carbonhydrate = val;\t return this;\t }\t\tpublic NutritionFacts build() {\t return new NutritionFacts(this);\t } }\tprivate NutritionFacts(Builder builder) {\t calories = builder.calories;\t\tfat = builder.fat;\t\tsodium = builder.sodium;\t\tcarbonhydrate = builder.carbonhydrate;\t}} 클라이언트는 필요한 객체를 직접 만드는 대신 필수 매개변수만으로 생성자를 호출해 빌더 객체를 얻는다 빌더 객체가 제공하는 세터 메소드들로 원하는 선택 매개변수들을 설정한다 마지막으로 매개변수가 없는 build 메서드를 호출해 객체(일반적으로 불변)를 얻는다.빌더의 세터 메서드들은 빌더 자신을 반환해 연쇄적으로 호출할 수 있다. 이러한 방식을 fluent API 혹은 method chaining이라고 한다단점은 빌더 생성 코드가 장황해서 매개변수 4개 이상은 되어야 값어치를 한다는 것이다. 그러나 시간이 지날수록 매개변수는 많아질 것이므로 처리해야 할 매개변수가 많다면 빌더 패턴을 사용하는것이 좋다.ITEM 3 - private 생성자나 열거 타입으로 싱글턴임을 보증하라싱글턴(singleton)이란? 인스턴스를 하나만 생성할 수 있는 클래스싱글턴을 만드는 방법 두가지를 소개한다. 두 방식 모두 생성자는 private으로 감춘다.public static final 필드 방식의 싱글턴public class Elvis {\t**public static final Elvis INSTANCE = new Elvis();**\tprivate Elvis() {...}\tpublic void leaveTheBuilding() {...}}장점은 public static 필드가 final이니 클래스가 싱글턴임이 명확하다.정적 팩토리 방식의 싱글턴public class Elvis {\t**private** static final Elvis INSTANCE = new Elvis();\tprivate Elvis() {...}\t**public static Elvis getInstance**() { return INSTANCE; }\tpublic void leaveTheBuilding() {...}}getInstance는 항상 같은 객체의 참조를 반환하므로 싱글턴을 유지할 수 있다.장점은 API를 바꾸지 않고도 싱글턴이 아니게 변경 가능하다는 점이다.그러나 위의 두 방식으로 만든 싱글턴 클래스를 역직렬화 할 때마다 새로운 인스턴스가 생성되는 의도치 않은 문제가 생기기 때문에 아래와 같이 readResolve 메서드를 추가해 주어야 한다.// 싱글턴임을 보장해주는 readResolve 메서드private Object readResolve() { // 진짜 Elvis를 반환하고, 가짜 Elvis는 가비지 컬렉터에 맡긴다. return INSTANCE;}또한 예외적으로 리플렉션 API인 AccessibleObject.setAccessible을 사용해 private 생성자를 호출할 수 있다. 이러한 경우는 생성자에서 두 번 이상 객체가 생성되려 할 때 예외를 던지게 하면 된다.Enum 타입 방식의 싱글턴public enum Elvis { INSTANCE; public void leaveTheBuilding() {...}}원소가 하나뿐인 Enum으로 싱글턴을 만드는 것.추가 작업 없이 직렬화에 유리하다. 위의 두 방법보다 추천. 그러나 만드려는 싱글턴이 Enum 외의 클래스를 상속해야 한다면 사용할 수 없다.ITEM 4 - 인스턴스화를 막으려거든 private 생성자를 사용하라정적 멤버만 담은 유틸리티 클래스와 같이, 클래스의 의도를 명확히 하기 위해 인스턴스화를 막아야 하는 경우가 있다.인스턴스화를 막으려면 private 생성자를 추가하자.명시된 생성자가 없으면 컴파일러가 기본 생성자를 자동 생성하고, 사용자는 이 생성자가 자동생성 된 것인지 구분할 수 없기 때문이다.public class UtilityClass { // 기본 생성자가 만들어지는 것을 막는다(인스턴스화 방지용)\t**private UtilityClass**() {\t\tthrow new AssertionError(); }}위의 private 생성자를 사용한 코드는 두가지 장점이 있다 클래스 인스턴스화를 막아준다 그러나 직관적이지 않은 코드이니, ‘인스턴스화 방지용’과 같은 주석을 달아주자 상속을 불가능하게 한다 하위클래스가 상위클래스의 생성자에 접근할 수 없어 생성자를 호출할 수 없다 ITEM 5 - 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라클래스가 내부적으로 하나 이상의 자원에 의존하고, 그 자원이 클래스의 동작에 영향을 주는 경우 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않다. ex) 맞춤법 검사기와 같이 사용하는 자원(언어, 특수 어휘 등…)에 따라 동작이 달라지는 클래스. 또한 이러한 경우에는 클래스가 직접 자원들을 만들게 해서도 안된다. 대신 필요한 자원을 (혹은 자원을 만드는 팩터리를) 생성자에 (혹은 정적 팩터리나 빌더에) 넘겨준다. 이 기법을 의존 객체 주입이라고 한다. 클래스의 유연성, 재사용성, 테스트 용이성을 개선해준다.ITEM 6 - 불필요한 객체 생성을 피하라필요없는 객체의 반복 생성을 막고 기존 객체를 재사용할 수 있는 방법들이다.문자열 리터럴을 사용하는 모든 코드가 같은 객체를 재사용함을 보장하라String s = new String(\"utility\");// 위의 코드 대신String s = \"utility\"같은 가상 머신 안에서 사용하는 동일한 문자열 리터럴을 사용하는 모든 코드가 같은 객체를 재사용함이 보장된다.불변 클래스에서 생성자 대신 정적 팩토리 메서드를 사용한다Boolean(String) 생성자 대신 Boolean.valueOf(String) 을 사용하는 것이 좋다.생성비용이 비싼 객체를 반복해 사용한다면 캐싱을 사용하자static boolean isRomanNumeral(String s) { return s.matches(\"^(?=.)M*(C[MD]|D?C{0,3})\" + \"(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$\");}위 코드의 단점은 String.matches 메서드가 Pattern 인스턴스를 한번 생성하고, 쓰고 버린다는 것이다. 성능이 중요한 경우 이 메서드를 반복해서 사용하는 것은 적합하지 않다.성능을 개선하기 위해 정규표현식을 표현하는 (불변)Pattern 인스턴스를 클래스 초기화(정적 초기화)과정에서 직접 생성해 캐싱해두고, 메서드가 호출될 때마다 이 인스턴스를 재사용한다.public class RomanNumerals { private static final Pattern ROMAN = Pattern.compile( \"^(?=.)M*(C[MD]|D?C{0,3})\" + \"(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$\"); static boolean isRomanNumeral(String s) { return ROMAN.matcher(s).matches(); }}박싱된 기본타입보다 기본타입을 사용하고 의도치 않은 오토박싱이 숨어들지 않도록 하자private static long sum() { Long sum = 0L; for(long i = 0; i &lt;= Integer.MAX_VALUE; i++) sum += i; return sum;}위 코드의 sum 변수의 타입을 long으로 변경하면 불필요한 Long 인스턴스를 231개나 아낄 수 있고, 속도도 6.3초에서 0.59초로 빨라진다.ITEM 7 - 다 쓴 객체 참조를 해제하라자바와 같은 가비지 컬렉션 언어에서 또한 메모리 누수에 주의하자. 객체 참조 하나를 회수하지 않으면 가비지 컬렉터는 그 객체가 참조하는 모든 객체를 회수하지 못한다. 따라서 성능에 악영향을 줄 수 있다.참조를 담은 변수의 scope를 최소가 되도록 적절히 정의했다면 변수가 유효 범위(scope)밖으로 벗어나는 때에 참조 해제는 자연스럽게 일어난다. 다만 아래와 같은 경우들은 객체 참조 해제에 유의하는 것이 좋다.자기 메모리를 직접 관리하는 클래스자기 메모리를 직접 관리하는 클래스의 경우 메모리 누수에 주의해야 한다.객체 참조를 담는 스택을 예시로 들면 비활성 영역은 더이상 사용되지 않는다. 가비지 컬렉터는 이러한 사실을 알 길이 없다. 그러므로 프로그래머는 비활성 영역이 되는 순간에 객체를 더이상 사용하지 않을것을 알리기 위해 null 처리 해야한다.public Object pop() { if (size == 0) throw new EmptyStackException(); Object result = elements[--size]; **elements[size] = null; // 참조 해제** return result;}위 코드의 또다른 장점은 해제한 참조를 이후에 사용했을 때 프로그램이 NullPointerException을 던지며 종료된다는 것이다. 프로그램의 오류는 가능한 조기에 발견되는 것이 좋다.캐시객체 참조를 캐시에 넣고 더이상 사용하지 않을 경우만약 캐시 외부에서 키를 참조하는 동안만 엔트리가 살아있는 캐시가 필요하다면 WeakHashMap을 사용한다. 이렇게 하면 다 쓴 엔트리는 즉시 자동으로 제거된다.이외에 엔트리 유효기간을 정확히 정의하기 어려울 경우, ScheduledThreadPoolExecutor와 같은 백그라운드 스레드를 사용하는 방법, 캐시에 새 엔트리를 추가할 때 추가 작업을 수행해주는 방법이 있다.listener 혹은 callback클라이언트가 콜백을 등록만 하고 해지하지 않는다면 콜백은 계속해서 쌓이기만 한다. 이러한 경우 콜백을 약한 참조(weak reference)로 저장하여 가비지 컬렉터가 즉시 수거해 가게끔 한다. ex) WeakHashMap에 키로 저장ITEM 8 - finalizer와 cleaner사용을 피하라자바에서는 객체 소멸자로 finalizer를 사용해왔다. finalizer는 예측이 어렵고 느리고 불편하여 자바9에서 cleaner사용을 권고하고 finalizer를 deprecated API로 지정하였다. 그러나 cleaner 역시도 동일한 단점을 가지고 있으며 일반적으로 불필요하다.cleaner와 finalizer는 즉시 실행을 보장하지 않아 예측이 어렵다. 실행 시점은 전적으로 가비지 컬렉터의 구현에 의존한다.cleaner의 쓰임은 아래 두가지의 경우이다. 사용시 불확실성과 성능 저하에 유의하자. 자원의 소유자가 close 메서드를 부르지 않는 것에 대한 안전망 역할 cleaner와 finalizer가 즉시 실행된다는 보장은 없지만 자원 회수를 늦게라도 해주는 것에 의의를 둔다 예) 자바 라이브러리 중 FileInputStream, FileOutputStream, ThreadPoolExecutor 중요하지 않은 네이티브 자원(native peer) 회수 가비지 컬렉터가 인식하지 못하는 네이티브 객체를 회수할 때 사용한다. 그러나 성능 저하와 즉시 회수가 불가능함을 감수해야 한다. 따라서 심각한 자원에는 사용할 수 없다. 위의 케이스에 해당하지 않는다면AutoCloseable을 구현하고, 클라이언트에서 인스턴스를 다 사용하고 나면 close 메서드를 호출한다. 이 때 각 인스턴스는 자신이 닫혀있는지 추적하는것이 좋다. close 메서드는 이 객체가 더이상 유효하지 않음을 필드에 기록하고 다시 불린다면 IllegalStateException을 던지도록 구현한다.ITEM 9 - try-finally 보다는 try-with-resources를 사용하라close메서드를 호출해 직접 닫아줘야 하는 자원이 제대로 닫힘을 보장하는 수단으로 try-finally를 사용해 왔다. finalizer도 사용했지만 finalizer는 단점이 많았다. 자바 7의 try-with-resources는 기존 try-finally의 기능과 단점들을 커버한다.try-finally의 단점static String firstLineOfFile(String path) throws IOException { BufferedReader br = new BufferedReader(new FileReader(path)); try { return br.readLine(); } finally { br.close(); }}하지만 자원이 둘 이상이면 코드가 지저분해진다.static void copy(String src, String dst) throws IOException { InputStream in = new FileInputStream(src); try { OutputStream out = new FileOutputStream(dst); try { byte[] buf = new byte[BUFFER_SIZE]; int n; while((n=in.read(buf)) &gt;=0 ) out.write(buf, 0, n); } finally { out.close(); } } finally { in.close(); }}또한 디버깅이 어렵다. try 블록에서 예외가 생기고 finally 블록에서도 예외가 생겼을 경우, 스택 추적 내역에 두번째 예외의 정보만 남고 첫번째 예외에 대한 정보가 남지 않을 것이기 때문이다.try-with-resources 구조를 사용하려면 해당 자원이 AutoCloseable 인터페이스를 구현해야 한다.static String firstLineOfFile(String path) throws IOException { try (BufferedReader br = new BufferedReader(new FileReader(path))) { return br.readLine(); }}자원이 둘 이상이라도 아래와 같이 깔끔하게 코드를 작성할 수 있다.static void copy(String src, String dst) throws IOException { try (InputStream in = new FileInputStream(src); OutputStream out = new FileOutputStream(dst)) {\t byte[] buf = new byte[BUFFER_SIZE];\t int n;\t while((n=in.read(buf)) &gt;=0 )\t out.write(buf, 0, n); }}디버깅도 간단하다. readLine과 close 호출 양쪽 모두 예외가 발생해도, close측의 예외는 숨겨지고 readLine의 예외가 기록된다. 숨겨진 예외는 surpressed라는 꼬리표를 달고 스택 추적 내역에 출력된다.catch 절을 사용하여 다수의 예외처리를 try문을 중첩하지 않고 할 수도 있다.static String firstLineOfFile(String path, String defaultVal) { try (BufferedReader br = new BufferedReader(new FileReader(path))) { return br.readLine(); } catch (IOException) { return defaultVal; }}" }, { "title": "Test-Driven Development / Kent Beck", "url": "/posts/book-test-driven-development/", "categories": "Blogging, Book", "tags": "TDD", "date": "2022-09-05 01:39:00 +0900", "snippet": "프로그래머는 자기 작업의 품질에 대해 우선적으로 책임을 질 수 있어야 한다.테스트 주도 개발은 책임을 맡는 방법이다. 테스트 주도 개발은 테스트라는 매커니즘을 통해 프로그래밍을 하며 생기는 두려움을 방지해 행동하고, 커뮤니케이션하게 한다.(용기)이 책을 통해 작업을 단순하게 시작하고 자동화된 테스트를 만들고 새로운 설계 결정을 하나씩 도입하는 리팩토링이 가능하다테스트 주도 개발의 목표“작동하는 깔끔한 코드(clean code that works)” - 론 제프리즈(Ron Jeffries)테스트 주도 개발의 규칙 자동화된 테스트가 실패할 경우에만 코드를 수정한다 중복을 제거한다테스트 주도 개발 CYCLE 빨강 🔴 - 실패하는 테스트를 만든다 초록 🟢 - 테스트를 통과하게끔 만든다 리팩토링 - 테스트만 통과하게 만드는중에 생겨난 중복을 제거한다 리팩토링이란? 코드의 외적 행위는 그대로 유지하면서 내부 구조를 변경하는 작업 예제는 아래와 같은 과정을 통해 진행되었다 작업해야할 테스트 목록을 만든다 외부에서 오퍼레이션이 어떻게 보일지 코드로 표현한다 테스트를 작성할 때는 오퍼레이션의 인터페이스를 먼저 생각해보는것이 좋다 스텁 구현을 통해 테스트를 컴파일한다. 스텁 구현(stub implementation)이란? 메서드의 서명부와 반환 명령만 적는 식으로 메소드를 호출하는 부분의 컴파일을 위한 껍데기 테스트를 통과하게 코드를 일부 변경한다 이 과정에서 끔찍한 죄악을 저지를 수도 있다고 한다 단순히 돌아가는 코드를 작은 단계로 점진적으로 일반화한다 작은 단계로 구현할 수 있는 능력을 갖추자 테스트를 통과시키는 세 가지 전략가짜로 구현하기먼저 상수를 반환하게 하고 단계적으로 구현하며 상수를 변수로 바꾸어 나간다명백한 구현 사용하기실제 구현을 입력한다.삼각측량법(Triangulation)여러 예제를 이용해 코드를 일반화한다격리된 테스트테스트의 공통된 패턴: 3A 패턴 - 빌 웨이크(Bill Wake) 준비(Arrange) - 객체를 생성 행동(Act) - 어떤 자극을 준다 확인(Assert) - 결과를 검사1의 객체 생성은 여러 테스트에서 동일하게 사용할 수 있다. 그렇다면 매번 새로 생성하지 않고 재활용해도 될까?이 문제에서는 두가지 제약이 상충한다. 성능 차원 - 같은 객체를 사용하면 빨리 실행될 수 있다. 격리 차원 - 한 테스트의 성공이나 실패가 다른 테스트에 영향을 주지 않기를 원한다. 만약 하나의 테스트가 객체의 상태를 변경한다면 다음 테스트의 결과에 영향을 미칠 수도 있다.결론은 테스트 사이의 커플링을 만들지 말자. 테스트 사이에 순서 또는 한 테스트의 결과가 다른 테스트의 결과에 영향을 미칠 경우, 한 테스트가 깨지면 다른 테스트들은 올바르더라도 깨지거나 최악의 경우 잘못된 테스트가 통과하는 안좋은 상황이 발생할 수 있다.테스트를 커플링 없이 작은 스케일로 격리하기 위해서, 시스템은 응집도가 높고 결합도는 낮은 객체 모음으로 구성되게 만들어야 한다.‘테스트할 시간이 없다’ 나선을 탈출위의 양성 피드백 고리(positive feedback loop)에 의해 스트레스를 많이 받으면 테스트를 점점 더 뜸하게 할것이고, 테스트를 뜸하게 하면 에러는 점점 더 많아질 것이다. 에러가 많아지면 스트레스를 받는다.이 고리에서 빠져나오기 위해서는 기존 요소와 바꿔치기를 하거나, 화살표를 바꾸면 된다.테스트 자동화기존 ‘테스트’를 ‘자동화된 테스트’로 치환한다. 자동화 테스트는 스트레스를 받는 상황에서 초록 막대로 안정감을 준다. 에러를 낼 일도 줄어들게 되고, 스트레스도 적어진다.테스트 우선위쪽에 있는 스트레스와 아래에 있는 테스트의 위치를 바꾸는 것이다. 테스트를 먼저 하면 화살표 아래 스트레스가 음성으로 연결되고, 테스트를 더 많이 하게 된다." }, { "title": "Spring IoC, AOP, PSA", "url": "/posts/spring-ioc-aop-psa/", "categories": "Blogging, Demo", "tags": "spring", "date": "2022-03-25 01:21:00 +0900", "snippet": "Spring자바 엔터프라이즈 개발을 위한 오픈소스 애플리케이션 프레임워크목적 : POJO를 이용한 애플리케이션 개발로 엔터프라이즈 시스템을 쉽고 효과적으로 개발하자POJO(Plain Old Java Object)순수한 자바 오브젝트과거 EJB가 인기일때 단순한 자바 오브젝트를 사용하지 않고 EJB에 종속적인 개발을 해왔다. 그러다 보니 모듈을 교체하거나, 시스템을 업그레이드할 때 종속성으로 인한 문제들이 생겨났다. 이러한 문제를 해결하기 위해 단순한 오브젝트를 이용해 애플리케이션의 비즈니스 로직을 구현하는 것이 POJO 프로그래밍이다.특징 특정 규약에 종속되지 않는다. 특정 라이브러리, 모듈에서 정의된 클래스를 상속받아 구현하지 않는다 특정 환경에 종속되지 않는다. 외부 종속적인 http request, session등을 사용하지 않는다 스프링은 주요 기술인 IoC/DI, AOP, PSA을 통해 POJO방식으로의 프로그래밍을 지원한다. IoC/DI, AOP, PSA를 POJO로 개발할 수 있게 해주는 가능기술이라고 부르기도 한다.IoC/DI ContainerIoC Container 객체가 자신의 dependency를 정의 constructor setter field 이후 IoC 컨테이너는 빈을 생성할때 dependency를 주입한다. (Object Reference를 주입)객체가 타 객체와 관계를 맺는 작업의 제어권을 IoC 컨테이너에 넘겼으므로 제어의 역전이라고 부른다.이제 객체는 자신이 사용할 대상의 생성이나 선택에 관한 책임을 벗어나 구현에만 집중할 수 있게 되었다.ApplicationContextBeanFactory는 빈을 관리하는 기능을 담당한다.ApplicationContext는 BeanFactory를 확장해 더 많은 엔터프라이즈 기능을 추가로 제공한다.org.springframework.context.ApplicationContext 인터페이스는 Spring IoC container를 나타내고 빈을 인스턴스화(instantiate)하고, 설정(configure)하고 구성(assemble)하는 역할을 한다.애플리케이션 class들은 ApplicationContext가 configuration metadata를 이용해 IoC를 적용한 후 실행 가능한 시스템이 된다.AOP(Aspect Oriented Programming)교차 관심사의 분리로 모듈성을 높이는 것을 목표로 하는 프로그래밍 패러다임대부분의 프로젝트에서는 로깅, 인증, 인가 등 도메인 로직과 관계없는 기능들이 중복된다.이러한 공통 기능들을 매번 똑같이 개발하고 유지보수 하지 않게(DRY : Don’t repeat yourself) 분리하여 개발하고 실행시에 스프링이 대신 조합할 수 있다.PSA(Portable Service Abstraction)POJO로 개발한 코드가 특정 환경과 기술에 종속되지 않고 일관된 방식으로 기술에 접근할 수 있게 해주는 서비스 추상화 기술" } ]
