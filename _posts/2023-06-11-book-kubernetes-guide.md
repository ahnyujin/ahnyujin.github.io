---
title: 쿠버네티스 완벽 가이드 / 마사야아오야마
author: Yujin Ahn
date: 2023-06-11 10:50:00 +0900
categories: [Blogging, Book]
tags: [Kubernetes]
---

# 1장 도커 복습과 Hello, Kubernetes

## 1.1 도커 복습

### **도커 컨테이너란?**

애플리케이션과 해당 애플리케이션을 실행하기 위한 실행환경을 패키징하여 애플리케이션을 쉽게 실행하기 위한 도구. 가상 머신은 하이퍼바이저를 이용하여 게스트 OS를 동작시키지만, 도커 컨테이너는 호스트 머신의 커널을 이용하여 네임스페이스 분리와 cgroups를 이용한 제어를 통해 독립적인 OS와 같은 환경을 만들 수 있다.

- 1 컨테이너당 1 프로세스
- 변경 불가능한 인프라(Immutable Infrastructure) 이미지로 생성한다.
- 경량의 도커 이미지로 생성한다
- 실행 계정은 root 이외의 사용자로 한다.

### 도커 이미지

```bash
# 도커 이미지 다운로드
$ docker image pull ${image}

# 도커 이미지 확인
$ docker image ls

# 도커 파일로 이미지 빌드
$ docker image build -t ${image}:{tag}
```

도커 이미지는 Dockerfile을 기반으로 빌드된다.

**사이즈별 이미지**

- 최소
    - scratch : 초경량, 셸이 설치되지 않아 디버그가 어렵다
- 작다
    - alpine
    - distroless : 특정 애플리케이션 런타임만 포함된 이미지
- 크다
    - ubuntu
    - centos
    - Universal Base Image

**멀티 스테이지 빌드**

여러 컨테이너 이미지를 사용하여 처리하고 결과물만 실행용 컨테이너 이미지에 복사한다. 소스 코드 컴파일에 필요한 도구를 실제 애플리케이션을 기동시키는 컨테이너에 포함시키지 않아도 되기 때문에 이미지 사이즈를 줄일 수 있다.

### **도커 레지스트리**

- 도커 이미지 보관하는 저장소 서버
- Docker Hub, Google Container Registry, Amazon Elastic Container Registry 등

**도커 허브에 이미지 업로드 하기**

도커 허브의 네임스페이스는 사용자의 이름이다.

```bash
# 도커 허브 로그인
$ docker login

# 방법 1. 이미지 태그 변경 후 업로드
# 이미지 태그 변경
$ docker image tag ${image}:${tag} ${DOCKERHUB_USER}/${image}:${tag}
# 도커 허브에 이미지 업로드
$ docker image push ${DOCKERHUB_USER}/${image}:${tag}

# 방법 2. 직접 푸시할 이름을 지정해 빌드
$ docker image build -t ${DOCKERHUB_USER}/${image}:${tag}

# 도커 허브 로그아웃

$ docker logout
```

### **도커 컨테이너 기동**

```bash
# 도커 컨테이너 기동 (localhost:12345 포트를 8080/TCP 포트로 전송)
$ docker container run -d -p 12345:8080 sample-image:0.1

# 애플리케이션 동작 확인
$ curl http://localhost:12345
```

# 2장 왜 쿠버네티스가 필요할까?

## 2.1 쿠버네티스란?

**컨테이너 오케스트레이션 엔진**

- 컨테이너화된 애플리케이션의 배포, 확장 등의 관리를 자동화한다.
- **쿠버네티스**, 도커 스윔, 아파지 메소스 등

**컨테이너 런타임**

- 도커, containerd, cri-o 등

쿠버네티스 노드

- 쿠버네티스에서 실제 컨테이너가 기동하는 노드(호스트기 되는 물리 머신이나 가상 머신)

쿠버네티스 마스터

- 쿠버네티스 노드를 관리하는 노드

컨테이너

- 어떤 애플리케이션을 실행하도록 빌드된 컨테이너 이미지를 기반으로 기동된 워크로드

### 2.3 쿠버네티스를 사용하면 무엇을 할 수 있을까?

- 선언적 코드(매니페스트)를 통해 컨테이너를 배포한다 (IaC)
    - YAML 형식, JSON 형식
- 스케일링/오토 스케일링
    - 컨테이너 클러스터를 구성하여 여러 쿠버네티스 노드를 관리한다
    - 레플리카를 배포해 부하 분산 및 다중화구조를 만든다
    - 부하에 따라 레플리카 수를 자동으로 조절해 오토 스케일링한다
- 스케줄링
    - Affinity, Anti-Affinity 기능을 사용하여 스케줄링할 수 있다
- 리소스 관리
    - 기본적으로 쿠버네티스 노드의 CPU, 메모리 여유 리소스 상태에 따라 스케줄링된다
    - 클러스터 오토 스케일링 기능으로 리소스 사용 상태에 따라 쿠버네티스 클러스터의 노드도 자동 추가 삭제할 수 있다
- 자동화된 복구(self-healing)
    - 표준으로 컨테이너 프로세스를 모니터링하고 정지를 감지하면 스케줄링을 실행하여 자동으로 재배포한다
- 로드 밸런싱과 서비스 디스커버리
    - 로드밸런서 기능
        - 서비스(Service), 인그레스(ingress)
        - 사전 정의된 조건과 일치하는 컨테이너 그룹에 라우팅하는 엔드포인트 할당
    - 서비스 디스커버리
        - 각각의 마이크로 서비스가 정의된 복수의 매니페스트를 이용해 시스템을 전체 연계
- 데이터 관리
    - 백엔드 데이터 스토어 etcd
        - 클러스터를 통한 이중화
        - 컨테이너나 서비스의 매니페스트 파일도 이중화
        - 애플리케이션에서 사용되는 설정파일, 데이터베이스 인증 정보 저장
- 외부 에코시스템과의 연계
    - Ansible : 쿠버네티스에 컨테이너 배포
    - Apache Ignite : 쿠버네티스 서비스 디스커버리를 이용한 클러스터 생성, 스케일링
    - Fluentd : 쿠버네티스에 컨테이너 로그 전송
    - Jenkins : 잡 실행자용 컨테이너를 쿠버네티스에 배포
    - OpenStack : 클라우드 사업자와 연계한 쿠버네티스 구축
    - Prometheus : 쿠버네티스 모니터링
    - Spark : 잡을 쿠버네티스에서 네이티브로 실행
    - Kubeflow : 쿠버네티스에 ML 플랫폼 배포
    - Rock : 쿠버네티스에 분산 파일 시스템 배포
    - V itess : 쿠버네티스에 MySQL 클러스터 배포
    - 그 외 다수

# 3장 쿠버네티스 환경 선택

### 쿠버네티스 환경과 도구

- 로컬 쿠버네티스 : 물리머신 한 대에 구축하여 사용
    - 미니큐브(Minikube)
    - Docker Desktop for Mac / Window
    - kind(Kubernetes in Docker)
- 쿠버네티스 구축 도구
    - 큐브어드민(kubeadm)
        - 쿠버네티스 공식 구축 도구
    - 플라넬
        - 노드 사이를 연결하는 네트워크에 오버레이 네트워크를 구성하여 쿠버네티스 클러스터 내부의 파드 간 통신을 구현한다.
    - 랜처(Rancher)
        - 쿠버네티스 구축과 운용을 지원하는 오픈 소스 컨테이너 플랫폼
        - 중앙에서 랜처 서버를 기동시키고 관리자는 랜처 서버를 통해 쿠버네티스 클러스터를 구축하고 관리
    - 그 외
        - 엔서블(Ansible)을 사용한 큐브스프레이(Kubespray)
        - 클라우드포메이션(CloudFormation)을 사용한 kube-aws
        - 테라폼(Terraform)이나 클라우드 포메이션 형식의 파일을 출력할 수 있는 캅스(kobs)
        - OpenStack Heat을 사용한 OpenStackMagnum
- 퍼블릭 클라우드 관리형 쿠버네티스 서비스
    - Google Kubernetes Engine(GKE)
    - Azure Kubernetes Service(AKS)
    - Elastic Kubernetes Service(EKS)
    

**쿠버네티스 서비스 수준 목표(Service Level Objective, SLO)**

SIG-Scalability의 서비스 수준 지표와 서비스 수준 목표

- API 응답 시간
    - 단일 객체의 변경 API 요청에 대해 지난 5분동안 99%가 1초 내에 돌아올 것(일부 제외)
    - 비스트리밍(non-streaming)의 API 요청에 대해 지난 5분 동안 99%가 아래 초 이내에 돌아올 것(일부 제외)
        - 특정 리소스: 1초
        - 네임스페이스 전체: 5초
        - 클러스터 전체: 30초
- 파드 기동 시간
    - 지난 5분 동안 99%가 5초 이내에 동작할 것
        - 이미지 다운로드 시간이나 초기화 컨테이너(Init Container) 처리시간은 포함하지 않음