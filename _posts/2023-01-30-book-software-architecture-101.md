---
title: 소프트웨어 아키텍처 101 / 마크 리처드, 닐 포드
author: Yujin Ahn
date: 2023-01-30 10:50:00 +0900
categories: [Blogging, Book]
tags: [Architecture]
---

# 소프트웨어 아키텍처 101 - 마크 리처즈, 닐 포드

# 1 서론

소프트웨어 아키텍트의 길은 왜 분명하지 않을까?

1. 직업 자체에 대한 명확한 정의가 없다
2. 업무 범위가 방대하다
    1. 과거 모듈성, 컴포넌트, 패턴 등 순수 기술적인 부분 + MSA 등 계속해서 확대
3. 소프트웨어 개발 생태계 발전에 따라 끊임없이 변화한다
4. 관련 자료들은 역사적 연관성을 강조한다

따라서 아키텍처를 공부하며 명심해야 할 것은, 현재의 환경에 맞는 결정을 하는 것이다.

소프트웨어 아키텍처는 시스템의 청사진이다. 시스템 아키텍처를 이해하는 방법 중 하나는 아래와 같다.

- 아키텍처 특성
- 아키텍처 결정
    - 반드시 지켜야 할 원칙
    - 시스템 제약 조건을 형성
- 설계 원칙
    - 가이드라인
- 시스템 구조
    - 마이크로서비스, 레이어드, 마이크로커널 등

**제1법칙** 소프트웨어 아키텍처의 모든 것은 다 trade-off이다.

**제2법칙** ‘어떻게’보다 ‘왜’에 더 주목해야 한다.

# 2 아키텍처 사고

아키텍처 사고란 아키텍처와 설계의 차이를 알고 둘을 통합한 솔루션을 모색하는 것.

- 아키텍처: 비즈니스 요구사항 분석→아키텍처 특성, 스타일, 컴포넌트 구조 도출
- 설계 : 아티팩트 → 컴포넌트의 클래스 설계, UI, 소스 코드

전통적인 역할 모델은 아키텍처→ 설계 단방향 이었으나, 제대로 된 아키텍처를 만들려면 소통의 단절을 부수고, 협력하여 프로젝트 생명 주기의 일부로 동기화 되어야 한다.

## 트레이드오프 분석

![Untitled](/assets/img/posts/architecture_trade_off.png)

입찰 프로듀서 서비스가 입찰을 생성하고 그 금액을 입찰 캡처, 추적, 분석 서비스에 전달하는 경매 시스템을 설계한다고 가정한다.

토픽을 이용한 서비스 간 통신을 이용할 경우

- 장점
    - 아키텍처 확장성(extensibility)
        - 입찰 이력을 조회하는 새로운 서비스를 도입하더라도 변경할 필요가 없는 구조이다.
    - 서비스 디커플링
        - 입찰 프로듀서 서비스는 입찰 정보를 어느 서비스가 어떻게 사용하는지 모른다
- 단점
    - 데이터 액세스, 보안 문제
        - 누구나 입찰 데이터에 액세스할 수 있으며 도청이 쉽다.
    - 서로 다른 계약 지원 불가
        - 토픽을 수신한 모든 서비스는 동일한 계약 및 데이터 세트를 받아야 한다.
    - 모니터링과 프로그래밍 방식의 확장성 떨어짐
        - 토픽 메시지 개수를 모니터링할 수 없고, auto-scaling 기능이 지원되지 않음

큐를 이용한 서비스 간 통신을 이용할 경우

- 장점
    - 데이터 액세스, 보안 문제
        - 큐를 수신하는 지정된 컨슈머만 접근 가능하다.
    - 개별 계약 지원
        - 토픽을 수신한 모든 서비스는 동일한 계약 및 데이터 세트를 받아야 한다.
    - 모니터링과 프로그래밍 방식의 확장성
        - 각 큐를 개별 모니터링 + 컨슈머 개별 로드 밸런싱 가능
- 단점
    - 아키텍처 확장성 떨어짐
        - 입찰 이력을 조회하는 새로운 서비스를 도입한다면, 서비스용 큐가 새로 필요하고, 프로듀서 서비스에 대한 변경이 불가피하다.
    - 서비스 커플링
        - 입찰 프로듀서 서비스는 입찰 정보가 어느 서비스에 어떻게 사용하는지 정확히 안다.

소프트웨어 아키텍처는 이런 트레이드오프를 분석하고 비즈니스 동인, 환경 등의 팩터에 따라 더 나은 방법을 택한다. (It depends!)

## 아키텍트가 코딩 실무 능력 유지하는 방법

- POC(proof-of-concept)를 자주 해본다
    - 각 제품을 응용한 예제 코드를 작성하고 실행 결과를 비교하여 공수, 솔루션의 확장성, 성능, 내고장성등의 아키텍처 특성을 비교한다.
    - 가능한 프로덕션 수준의 좋은 코드를 작성하여 레퍼런스 아키텍처나 다른 사람들이 참고할만한 샘플 코드로 만들자.
- 기술 부채 스토리나 아키텍처 스토리에 전념한다
- 버그를 잡는다
- 개발팀 프로세스 자동화 툴을 만든다
- 피트니스 함수를 사용해 아키텍처 컴플라이언스를 자동화한다
- 코드리뷰를 한다

# 3 모듈성

모든 플랫폼은 연관된 코드를 모듈로 묶는 방법을 지원한다. 또한 아키텍트가 분석해야할 메트릭, 피트니스 함수, 시각화 등 많은 도구가 모듈성에 기반한다.

모듈성은 일종의 구성 원리(organizing principle)로 증가하는 소프트웨어 시스템 엔트로피를 모델링하고, 질서를 유지한다.

모듈은 복잡한 구조를 만드는 데 쓰이는 각각의 표준화된 부품이나 독립적인 단위이다.

아키텍트는 개발자각 코드를 어떻게 패키징하는지 알아야 한다. 여러 패키지가 단단히 커플링되어있으면 그 중 하나를 다른 작업에 사용하기 어려워진다.

## 모듈성 측정

### 응집

응집(cohesion)은 모듈을 구성하는 구성요소가 서로 얼마나 연관되어 있는가를 나타낸다. 응집은 커플링보다 덜 정확한 메트릭으로 아키텍처 재량에 따라 다르게 측정될 수 있다.

응집도의 측정 범위, 좋은 순서대로

- 기능적 응집(functional cohesion)
    - 모듈의 각 파트는 나머지 파트와 연결되어 있고 기능상 필요한 모든 것이 모듈에 존재한다.
- 순차적 응집(sequential cohesion)
    - 두 모듈이, 한쪽에 데이터를 출력하면 다른 쪽이 그것을 입력 받는 형태로 상호작용한다.
- 소통적 응집(communication cohesion)
    - 두 모듈이, 각자 정보에 따라 작동하거나 어떤 출력을 내는 형태로 통신 체인을 형성한다.
- 절차적 응집(procedural cohesion)
    - 두 모듈은 정해진 순서대로 실행된다.
- 일시적 응집(temporal cohesion)
    - 모듈이 시점 의존성(timing dependency)에 따라 연관된다.
- 논리적 응집(logical cohesion)
    - 기능이 아닌 논리적으로 응집되어있다. 자바 프로젝트의 StringUtils 패키지가 좋은 예.
- 동시적 응집(coincidental cohesion)
    - 같은 소스 파일에 모듈 구성요소가 들어가있지만 아무런 연관성이 없다.

LCOM(Lack of Cohesion in Methods)

카이댐버와 케메러의 매서드의 응집 결여도이다. 공유 필드를 통해 공유되지 않는 메서드의 총 개수를 뜻한다.

$$
LCOM96b = \frac{1}{a}\sum_{k=0}^{a}
\frac{m-\mu(Aj)}{m}
$$

### 커플링

추상도(abstractness)는 추상 클래스, 인터페이스 등의 추상 아티팩트(abstract artifact)와 구상 아티팩트(concrete artifact, 구현체)의 비율, 즉 구현 대비 추상화를 나타낸다.

$$
A(추상도) = \frac{\sum m^a}{\sum m^c}
$$

불안정도(instanbility)는 코드베이스의 변동성을 의미한다. 원심 커플링과 (구심 커플링 + 원심 커플링)의 비율로 계산한다.

구심커플링은 컴포넌트, 클래스, 함수 등의 코드 아티팩트로 유입되는 접속 수를 의미한다.

원심 커플링은 다른 코드 아티팩트로 유출되는 접속 수를 나타낸다.

$$
I(불안정도)=\frac{C^e}{C^e+C^a}
$$

메인 시퀀스로부터의 거리(distance from the main sequence)

추상도와 불안정도를 이용하여 이상적인 관계를 계산한다.

$$
D = |A+I-1|
$$

- 그래프가 오른쪽 위로 치우칠 경우
    - 쓸모없는 구역(zone of useless)
    - 추상화를 너무 많이해서 사용하기 어려운 코드
- 그래프가 왼쪽 아래로 치우칠 경우
    - 고통스러운 구역(zone of pain)
    - 추상화를 거의 안하고 구현만 잔뜩 넣어 취약하고 관리하기 어려운 코드

### 커네이선스

두 컴포넌트 중 한쪽이 변경될 경우 다른 쪽도 변경해야 전체 시스템 정합성이 맞는다면 커네이선스를 갖는다.

커네이선스는 정적 커네이선스와 동적 커네이선스로 분류할 수 있다.

- 정적 커네이선스(static connascence)
    - 소스 코드 레벨의 커플링으로 구심/원심 커플링을 발전시킨 개념
    - 명칭 커네이선스(CoN)
        - 여러 컴포넌트의 엔티티명이 일치해야 한다.
    - 타입 커네이선스(CoT)
        - 여러 컴포넌트의 엔티티 타입이 일치해야 한다.
    - 의미 커네이선스(CoM) 또는 관례 커네이선스(CoC)
        - 여러 컴포넌트에 걸쳐 어떤 값의 의미가 일치해야 한다.
        - 예) 상수 대신 숫자를 하드코딩하는 경우
    - 위치 커네이선스(CoP)
        - 여러 컴포넌트는 값의 순서가 일치해야 한다.
        - 예) 매개변수
    - 알고리즘 커네이선스(CoA)
        - 여러 컴포넌트는 특정 알고리즘이 일치해야 한다.
        - 예) 보안 해시 알고리즘
- 동적 커네이선스(dynamic connascence)
    - 런타임 호출을 분석하는 커네이선스
    - 실행 커네이선스(CoE)
        - 여러 컴포넌트의 실행 순서가 중요하다.
    - 시점 커네이선스(CoT)
        - 여러 컴포넌트의 실행 시점이 중요하다.
        - 예) 동시에 실행 중인 두 스레드 때문에 경합 조건이 발생하여 공동 작업의 결과에 영향을 끼치는 경우
    - 값 커네이선스(CoV)
        - 상호 연관된 다수의 값들을 함께 변경한다.
        - 예) 트랜잭션
    - 식별 커네이선스(Col)
        - 여러 컴포넌트가 동일한 엔티티를 참조한다.
        - 예) 독립적인 두 컴포넌트가 분산 큐같은 자료구조를 공유해서 업데이트 하는 경우

커네이선스 속성은 다음과 같이 분석할 수 있다.

- 강도
    - 아키텍트와 개발자는 더 나은 유형의 커네이선스를 리팩토링해서 코트베이스의 커플링 특성을 개선할 수 있다.
    - 정적 커네이선스는 소스 코드 분석 또는 최신 도구를 이용해 쉽게 개선할 수 있다.
- 지역성
    - 코드베이스의 모듈이 서로 얼마나 가까이 있는가
    - 근접한 코드는 일반적으로 분리된 코드보다 높은 형태의 커네이선스를 가진다.
- 정도
    - 커네이선스가 미치는 영향의 규모
        - 소수의 클래스에 영향을 미치는가, 수많은 클래스에 영향을 미치는가
    - 강한 정도의 커네이선스를 약한 정도의 커네이선스로 전환하는 것이 좋다.

1990년대 커네이선스의 문제점

- 아키텍트가 관심 있어하는 아키텍처의 구조보다 저수준 코드의 세부분을 관찰한다.
- 아키텍트가 내려야할 근본적인 결정에 관한 문제는 다루지 않는다.

# 4 아키텍처 특성 정의

아키텍트는 개발팀과 함께 도메인, 비즈니스 요구사항을 정의할 수 있지만, 주로 소프트웨어로 처리할 일 중 도메인 기능과 직접적인 관련이 없는 모든 것들, 즉 아키텍처 특성을 정의, 발견, 분석하는 일을 수행한다.

비기능 요구사항, 품질 속성이라는 말도 많이 사용하지만 부정적인 인상을 주는 단어로 아키텍처 특성이라는 용어를 선호한다.

아키텍처 특성의 기준은 다음과 같다.

- 비도메인 설계 고려 사항을 명시한다.
    - 애플리케이션으로 처리할 일은 구체적인 요구사항으로 정리한다.
    - 요구사항을 구현 하는 방법, 선택을 하게 된 이유와 관련된 운영/설계 기준을 명시한다.
- 설계의 구조적 측면에 영향을 미친다.
    - 이 아키텍처 특성은 어떤 특별한 구조적 요소를 고려해야 하는가?
- 애플리케이션 성공에 절대적으로 중요하다.
    - 아키텍처 특성에 따른 설계 복잡도 가중을 고려하여 가급적 아키텍처 특성을 작게 선정하는 일도 중요하다.
    - 아키텍처의 명시적 특성과 암묵적 특성
        - 명시적 특성
            - 요구사항 정의서나 다른 지침서에 개시된 특성
        - 암묵적 특성
            - 요구사항 정의서에 없지만 프로젝트 성공을 위해 필요한 특성
            - 가용성, 신뢰성, 보안 등 애플리케이션의 근간

## 아키텍처 특성 목록

### 운영 아키텍처 특성

- 가용성(availability)
    - 시스템이 얼마나 오랫동안 사용 가능해야 하는가
- 연속성(continuaility)
    - 재해 복구 능력
- 성능(performance)
    - 스트레스 테스트, 피크 분석, 기능의 사용 빈도 분석, 필요 용량, 응답 시간 등
- 복구성(recoverability)
    - 비즈니스 연속성 요구사항, 백업 전략과 하드웨어 다중화 요건에 영향을 미친다.
- 신뢰성/안전(reliability/safety)
    - 시스템에 페일 세이프가 필요한가? 시스템 실패 시 회사에 거액 손실이 발생하는가?
- 견고성(robustness)
    - 프로그램 실행 중 인터넷 접속 끊김, 정전, 하드웨어 실패 등 에러 및 경계 조건을 감당하는 능력
- 확장성(scalability)
    - 유저 수, 요청 수가 늘어나도 시스템이 그에 맞는 성능을 발휘하는 능력

### 구조 아키텍처 특성

- 설정성(configurability)
    - 최종 유저가 편한 인터페이스를 통해 소프트웨어 설정을 쉽게 바꿀 수 있는가?
- 신장성(extensibility)
    - 새로운 기능을 삽입하는 일의 중요성
- 설치성(installability)
    - 필요한 모든 플랫폼에 쉽게 시스템을 설치할 수 있는가?
- 활용성/재사용(leverageability/reuse)
    - 공통 컴포넌트를 여러 제품에 활용할 수 있나?
- 지역성(locality)
    - 데이터 입력/조회하는 화면에서 다국어가 지원되는가?
- 유지보수성(maintainability)
    - 시스템을 얼마나 쉽게 변경/개선할 수 있나?
- 이식성(portability)
    - 하나 이상의 플랫폼에서 시스템을 실행할 수 있나?
- 지원성(supportability)
    - 애플리케이션은 어느 정도의 기술 지원을 필요로 하나? 시스템에서 발생한 에러를 디버깅하려면 로깅 및 기타 기능이 어느 수준으로 뒷받침되어야 하는가?
- 업그레이드성(upgradeability)
    - 이 애플리케이션/솔루션의 구 버전을 새 버전으로 쉽고 빠르게 업그레이드할 수 있는가?

### 아키텍처 공통 특성

- 접근성(accessibility)
    - 색맹, 청각 장애인 등 모든 유저가 접근하는 데 불편함이 없는가?
- 보관성(archivability)
    - 데이터를 따로 아카이빙해야 하나, 아니면 일정 시간 경과 후 삭제해야 하나?
- 인증(authentication)
    - 유저가 본인이 맞다는 것을 증명하기 위해 필요한 보안 요구사항
- 인가(authorization)
    - 유저가 애플리케이션에서 정해진 기능만 사용할 수 있도록 강제하는 보안 요구사항
- 합법성(legal)
    - 시스템 운영상 법적 제약조건이 있는가?
- 프라이버시(privacy)
    - 회사 내부 임직원의 트랜잭션을 외부에 드러내지 않는 기능
- 보안(security)
    - 데이터를 암호화한 후 데이터베이스에 보관해야 하나? 내부 시스템 간 네트워크 통신도 암호화해야 하나? 원격 유저 액세스는 어떤 종류의 인증이 필요한가?
- 사용성/성취성(usability/achieveability)
    - 유저가 애플리케이션/솔루션을 이용하여 원하는 목적을 달성하기 위해 필요한 교육/훈련 수준

### 최고의 아키텍처를 고집하지 말고 나쁜 것 중에서 제일 나은 아키텍처를 선택하라

아키텍처가 내린 결정은 상충되는 여러 문제들이 뒤얽힌 트레이드오프로 귀결되는 경우가 많다.

애자일 소프트웨어의 교훈과 같이, 가능한 한 아키텍처 설계를 꾸준히 반복해보는 것이 좋다.
