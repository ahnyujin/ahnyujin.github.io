---
title: 소프트웨어 아키텍처 101 / 마크 리처드, 닐 포드
author: Yujin Ahn
date: 2023-01-30 10:50:00 +0900
categories: [Blogging, Book]
tags: [Architecture]
---

# 소프트웨어 아키텍처 101 - 마크 리처즈, 닐 포드

# 1 서론

소프트웨어 아키텍트의 길은 왜 분명하지 않을까?

1. 직업 자체에 대한 명확한 정의가 없다
2. 업무 범위가 방대하다
    1. 과거 모듈성, 컴포넌트, 패턴 등 순수 기술적인 부분 + MSA 등 계속해서 확대
3. 소프트웨어 개발 생태계 발전에 따라 끊임없이 변화한다
4. 관련 자료들은 역사적 연관성을 강조한다

따라서 아키텍처를 공부하며 명심해야 할 것은, 현재의 환경에 맞는 결정을 하는 것이다.

소프트웨어 아키텍처는 시스템의 청사진이다. 시스템 아키텍처를 이해하는 방법 중 하나는 아래와 같다.

- 아키텍처 특성
- 아키텍처 결정
    - 반드시 지켜야 할 원칙
    - 시스템 제약 조건을 형성
- 설계 원칙
    - 가이드라인
- 시스템 구조
    - 마이크로서비스, 레이어드, 마이크로커널 등

**제1법칙** 소프트웨어 아키텍처의 모든 것은 다 trade-off이다.

**제2법칙** ‘어떻게’보다 ‘왜’에 더 주목해야 한다.

# 2 아키텍처 사고

아키텍처 사고란 아키텍처와 설계의 차이를 알고 둘을 통합한 솔루션을 모색하는 것.

- 아키텍처: 비즈니스 요구사항 분석→아키텍처 특성, 스타일, 컴포넌트 구조 도출
- 설계 : 아티팩트 → 컴포넌트의 클래스 설계, UI, 소스 코드

전통적인 역할 모델은 아키텍처→ 설계 단방향 이었으나, 제대로 된 아키텍처를 만들려면 소통의 단절을 부수고, 협력하여 프로젝트 생명 주기의 일부로 동기화 되어야 한다.

## 트레이드오프 분석

![Untitled](/assets/img/posts/architecture_trade_off.png)

입찰 프로듀서 서비스가 입찰을 생성하고 그 금액을 입찰 캡처, 추적, 분석 서비스에 전달하는 경매 시스템을 설계한다고 가정한다.

토픽을 이용한 서비스 간 통신을 이용할 경우

- 장점
    - 아키텍처 확장성(extensibility)
        - 입찰 이력을 조회하는 새로운 서비스를 도입하더라도 변경할 필요가 없는 구조이다.
    - 서비스 디커플링
        - 입찰 프로듀서 서비스는 입찰 정보를 어느 서비스가 어떻게 사용하는지 모른다
- 단점
    - 데이터 액세스, 보안 문제
        - 누구나 입찰 데이터에 액세스할 수 있으며 도청이 쉽다.
    - 서로 다른 계약 지원 불가
        - 토픽을 수신한 모든 서비스는 동일한 계약 및 데이터 세트를 받아야 한다.
    - 모니터링과 프로그래밍 방식의 확장성 떨어짐
        - 토픽 메시지 개수를 모니터링할 수 없고, auto-scaling 기능이 지원되지 않음

큐를 이용한 서비스 간 통신을 이용할 경우

- 장점
    - 데이터 액세스, 보안 문제
        - 큐를 수신하는 지정된 컨슈머만 접근 가능하다.
    - 개별 계약 지원
        - 토픽을 수신한 모든 서비스는 동일한 계약 및 데이터 세트를 받아야 한다.
    - 모니터링과 프로그래밍 방식의 확장성
        - 각 큐를 개별 모니터링 + 컨슈머 개별 로드 밸런싱 가능
- 단점
    - 아키텍처 확장성 떨어짐
        - 입찰 이력을 조회하는 새로운 서비스를 도입한다면, 서비스용 큐가 새로 필요하고, 프로듀서 서비스에 대한 변경이 불가피하다.
    - 서비스 커플링
        - 입찰 프로듀서 서비스는 입찰 정보가 어느 서비스에 어떻게 사용하는지 정확히 안다.

소프트웨어 아키텍처는 이런 트레이드오프를 분석하고 비즈니스 동인, 환경 등의 팩터에 따라 더 나은 방법을 택한다. (It depends!)

## 아키텍트가 코딩 실무 능력 유지하는 방법

- POC(proof-of-concept)를 자주 해본다
    - 각 제품을 응용한 예제 코드를 작성하고 실행 결과를 비교하여 공수, 솔루션의 확장성, 성능, 내고장성등의 아키텍처 특성을 비교한다.
    - 가능한 프로덕션 수준의 좋은 코드를 작성하여 레퍼런스 아키텍처나 다른 사람들이 참고할만한 샘플 코드로 만들자.
- 기술 부채 스토리나 아키텍처 스토리에 전념한다
- 버그를 잡는다
- 개발팀 프로세스 자동화 툴을 만든다
- 피트니스 함수를 사용해 아키텍처 컴플라이언스를 자동화한다
- 코드리뷰를 한다

# 3 모듈성

모든 플랫폼은 연관된 코드를 모듈로 묶는 방법을 지원한다. 또한 아키텍트가 분석해야할 메트릭, 피트니스 함수, 시각화 등 많은 도구가 모듈성에 기반한다.

모듈성은 일종의 구성 원리(organizing principle)로 증가하는 소프트웨어 시스템 엔트로피를 모델링하고, 질서를 유지한다.

모듈은 복잡한 구조를 만드는 데 쓰이는 각각의 표준화된 부품이나 독립적인 단위이다.

아키텍트는 개발자각 코드를 어떻게 패키징하는지 알아야 한다. 여러 패키지가 단단히 커플링되어있으면 그 중 하나를 다른 작업에 사용하기 어려워진다.

## 모듈성 측정

### 응집

응집(cohesion)은 모듈을 구성하는 구성요소가 서로 얼마나 연관되어 있는가를 나타낸다. 응집은 커플링보다 덜 정확한 메트릭으로 아키텍처 재량에 따라 다르게 측정될 수 있다.

응집도의 측정 범위, 좋은 순서대로

- 기능적 응집(functional cohesion)
    - 모듈의 각 파트는 나머지 파트와 연결되어 있고 기능상 필요한 모든 것이 모듈에 존재한다.
- 순차적 응집(sequential cohesion)
    - 두 모듈이, 한쪽에 데이터를 출력하면 다른 쪽이 그것을 입력 받는 형태로 상호작용한다.
- 소통적 응집(communication cohesion)
    - 두 모듈이, 각자 정보에 따라 작동하거나 어떤 출력을 내는 형태로 통신 체인을 형성한다.
- 절차적 응집(procedural cohesion)
    - 두 모듈은 정해진 순서대로 실행된다.
- 일시적 응집(temporal cohesion)
    - 모듈이 시점 의존성(timing dependency)에 따라 연관된다.
- 논리적 응집(logical cohesion)
    - 기능이 아닌 논리적으로 응집되어있다. 자바 프로젝트의 StringUtils 패키지가 좋은 예.
- 동시적 응집(coincidental cohesion)
    - 같은 소스 파일에 모듈 구성요소가 들어가있지만 아무런 연관성이 없다.

LCOM(Lack of Cohesion in Methods)

카이댐버와 케메러의 매서드의 응집 결여도이다. 공유 필드를 통해 공유되지 않는 메서드의 총 개수를 뜻한다.

$$
LCOM96b = \frac{1}{a}\sum_{k=0}^{a}
\frac{m-\mu(Aj)}{m}
$$

### 커플링

추상도(abstractness)는 추상 클래스, 인터페이스 등의 추상 아티팩트(abstract artifact)와 구상 아티팩트(concrete artifact, 구현체)의 비율, 즉 구현 대비 추상화를 나타낸다.

$$
A(추상도) = \frac{\sum m^a}{\sum m^c}
$$

불안정도(instanbility)는 코드베이스의 변동성을 의미한다. 원심 커플링과 (구심 커플링 + 원심 커플링)의 비율로 계산한다.

구심커플링은 컴포넌트, 클래스, 함수 등의 코드 아티팩트로 유입되는 접속 수를 의미한다.

원심 커플링은 다른 코드 아티팩트로 유출되는 접속 수를 나타낸다.

$$
I(불안정도)=\frac{C^e}{C^e+C^a}
$$

메인 시퀀스로부터의 거리(distance from the main sequence)

추상도와 불안정도를 이용하여 이상적인 관계를 계산한다.

$$
D = |A+I-1|
$$

- 그래프가 오른쪽 위로 치우칠 경우
    - 쓸모없는 구역(zone of useless)
    - 추상화를 너무 많이해서 사용하기 어려운 코드
- 그래프가 왼쪽 아래로 치우칠 경우
    - 고통스러운 구역(zone of pain)
    - 추상화를 거의 안하고 구현만 잔뜩 넣어 취약하고 관리하기 어려운 코드

### 커네이선스

두 컴포넌트 중 한쪽이 변경될 경우 다른 쪽도 변경해야 전체 시스템 정합성이 맞는다면 커네이선스를 갖는다.

커네이선스는 정적 커네이선스와 동적 커네이선스로 분류할 수 있다.

- 정적 커네이선스(static connascence)
    - 소스 코드 레벨의 커플링으로 구심/원심 커플링을 발전시킨 개념
    - 명칭 커네이선스(CoN)
        - 여러 컴포넌트의 엔티티명이 일치해야 한다.
    - 타입 커네이선스(CoT)
        - 여러 컴포넌트의 엔티티 타입이 일치해야 한다.
    - 의미 커네이선스(CoM) 또는 관례 커네이선스(CoC)
        - 여러 컴포넌트에 걸쳐 어떤 값의 의미가 일치해야 한다.
        - 예) 상수 대신 숫자를 하드코딩하는 경우
    - 위치 커네이선스(CoP)
        - 여러 컴포넌트는 값의 순서가 일치해야 한다.
        - 예) 매개변수
    - 알고리즘 커네이선스(CoA)
        - 여러 컴포넌트는 특정 알고리즘이 일치해야 한다.
        - 예) 보안 해시 알고리즘
- 동적 커네이선스(dynamic connascence)
    - 런타임 호출을 분석하는 커네이선스
    - 실행 커네이선스(CoE)
        - 여러 컴포넌트의 실행 순서가 중요하다.
    - 시점 커네이선스(CoT)
        - 여러 컴포넌트의 실행 시점이 중요하다.
        - 예) 동시에 실행 중인 두 스레드 때문에 경합 조건이 발생하여 공동 작업의 결과에 영향을 끼치는 경우
    - 값 커네이선스(CoV)
        - 상호 연관된 다수의 값들을 함께 변경한다.
        - 예) 트랜잭션
    - 식별 커네이선스(Col)
        - 여러 컴포넌트가 동일한 엔티티를 참조한다.
        - 예) 독립적인 두 컴포넌트가 분산 큐같은 자료구조를 공유해서 업데이트 하는 경우

커네이선스 속성은 다음과 같이 분석할 수 있다.

- 강도
    - 아키텍트와 개발자는 더 나은 유형의 커네이선스를 리팩토링해서 코트베이스의 커플링 특성을 개선할 수 있다.
    - 정적 커네이선스는 소스 코드 분석 또는 최신 도구를 이용해 쉽게 개선할 수 있다.
- 지역성
    - 코드베이스의 모듈이 서로 얼마나 가까이 있는가
    - 근접한 코드는 일반적으로 분리된 코드보다 높은 형태의 커네이선스를 가진다.
- 정도
    - 커네이선스가 미치는 영향의 규모
        - 소수의 클래스에 영향을 미치는가, 수많은 클래스에 영향을 미치는가
    - 강한 정도의 커네이선스를 약한 정도의 커네이선스로 전환하는 것이 좋다.

1990년대 커네이선스의 문제점

- 아키텍트가 관심 있어하는 아키텍처의 구조보다 저수준 코드의 세부분을 관찰한다.
- 아키텍트가 내려야할 근본적인 결정에 관한 문제는 다루지 않는다.