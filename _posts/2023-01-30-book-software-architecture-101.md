---
title: 소프트웨어 아키텍처 101 / 마크 리처드, 닐 포드
author: Yujin Ahn
date: 2023-01-30 10:50:00 +0900
categories: [Blogging, Book]
tags: [Architecture]
---

# 소프트웨어 아키텍처 101 - 마크 리처즈, 닐 포드

# 1 서론

소프트웨어 아키텍트의 길은 왜 분명하지 않을까?

1. 직업 자체에 대한 명확한 정의가 없다
2. 업무 범위가 방대하다
    1. 과거 모듈성, 컴포넌트, 패턴 등 순수 기술적인 부분 + MSA 등 계속해서 확대
3. 소프트웨어 개발 생태계 발전에 따라 끊임없이 변화한다
4. 관련 자료들은 역사적 연관성을 강조한다

따라서 아키텍처를 공부하며 명심해야 할 것은, 현재의 환경에 맞는 결정을 하는 것이다.

소프트웨어 아키텍처는 시스템의 청사진이다. 시스템 아키텍처를 이해하는 방법 중 하나는 아래와 같다.

- 아키텍처 특성
- 아키텍처 결정
    - 반드시 지켜야 할 원칙
    - 시스템 제약 조건을 형성
- 설계 원칙
    - 가이드라인
- 시스템 구조
    - 마이크로서비스, 레이어드, 마이크로커널 등

**제1법칙** 소프트웨어 아키텍처의 모든 것은 다 trade-off이다.

**제2법칙** ‘어떻게’보다 ‘왜’에 더 주목해야 한다.

# 2 아키텍처 사고

아키텍처 사고란 아키텍처와 설계의 차이를 알고 둘을 통합한 솔루션을 모색하는 것.

- 아키텍처: 비즈니스 요구사항 분석→아키텍처 특성, 스타일, 컴포넌트 구조 도출
- 설계 : 아티팩트 → 컴포넌트의 클래스 설계, UI, 소스 코드

전통적인 역할 모델은 아키텍처→ 설계 단방향 이었으나, 제대로 된 아키텍처를 만들려면 소통의 단절을 부수고, 협력하여 프로젝트 생명 주기의 일부로 동기화 되어야 한다.

## 트레이드오프 분석

![Untitled](/assets/img/posts/architecture_trade_off.png)

입찰 프로듀서 서비스가 입찰을 생성하고 그 금액을 입찰 캡처, 추적, 분석 서비스에 전달하는 경매 시스템을 설계한다고 가정한다.

토픽을 이용한 서비스 간 통신을 이용할 경우

- 장점
    - 아키텍처 확장성(extensibility)
        - 입찰 이력을 조회하는 새로운 서비스를 도입하더라도 변경할 필요가 없는 구조이다.
    - 서비스 디커플링
        - 입찰 프로듀서 서비스는 입찰 정보를 어느 서비스가 어떻게 사용하는지 모른다
- 단점
    - 데이터 액세스, 보안 문제
        - 누구나 입찰 데이터에 액세스할 수 있으며 도청이 쉽다.
    - 서로 다른 계약 지원 불가
        - 토픽을 수신한 모든 서비스는 동일한 계약 및 데이터 세트를 받아야 한다.
    - 모니터링과 프로그래밍 방식의 확장성 떨어짐
        - 토픽 메시지 개수를 모니터링할 수 없고, auto-scaling 기능이 지원되지 않음

큐를 이용한 서비스 간 통신을 이용할 경우

- 장점
    - 데이터 액세스, 보안 문제
        - 큐를 수신하는 지정된 컨슈머만 접근 가능하다.
    - 개별 계약 지원
        - 토픽을 수신한 모든 서비스는 동일한 계약 및 데이터 세트를 받아야 한다.
    - 모니터링과 프로그래밍 방식의 확장성
        - 각 큐를 개별 모니터링 + 컨슈머 개별 로드 밸런싱 가능
- 단점
    - 아키텍처 확장성 떨어짐
        - 입찰 이력을 조회하는 새로운 서비스를 도입한다면, 서비스용 큐가 새로 필요하고, 프로듀서 서비스에 대한 변경이 불가피하다.
    - 서비스 커플링
        - 입찰 프로듀서 서비스는 입찰 정보가 어느 서비스에 어떻게 사용하는지 정확히 안다.

소프트웨어 아키텍처는 이런 트레이드오프를 분석하고 비즈니스 동인, 환경 등의 팩터에 따라 더 나은 방법을 택한다. (It depends!)

## 아키텍트가 코딩 실무 능력 유지하는 방법

- POC(proof-of-concept)를 자주 해본다
    - 각 제품을 응용한 예제 코드를 작성하고 실행 결과를 비교하여 공수, 솔루션의 확장성, 성능, 내고장성등의 아키텍처 특성을 비교한다.
    - 가능한 프로덕션 수준의 좋은 코드를 작성하여 레퍼런스 아키텍처나 다른 사람들이 참고할만한 샘플 코드로 만들자.
- 기술 부채 스토리나 아키텍처 스토리에 전념한다
- 버그를 잡는다
- 개발팀 프로세스 자동화 툴을 만든다
- 피트니스 함수를 사용해 아키텍처 컴플라이언스를 자동화한다
- 코드리뷰를 한다

# 3 모듈성

모든 플랫폼은 연관된 코드를 모듈로 묶는 방법을 지원한다. 또한 아키텍트가 분석해야할 메트릭, 피트니스 함수, 시각화 등 많은 도구가 모듈성에 기반한다.

모듈성은 일종의 구성 원리(organizing principle)로 증가하는 소프트웨어 시스템 엔트로피를 모델링하고, 질서를 유지한다.

모듈은 복잡한 구조를 만드는 데 쓰이는 각각의 표준화된 부품이나 독립적인 단위이다.

아키텍트는 개발자각 코드를 어떻게 패키징하는지 알아야 한다. 여러 패키지가 단단히 커플링되어있으면 그 중 하나를 다른 작업에 사용하기 어려워진다.

## 모듈성 측정

### 응집

응집(cohesion)은 모듈을 구성하는 구성요소가 서로 얼마나 연관되어 있는가를 나타낸다. 응집은 커플링보다 덜 정확한 메트릭으로 아키텍처 재량에 따라 다르게 측정될 수 있다.

응집도의 측정 범위, 좋은 순서대로

- 기능적 응집(functional cohesion)
    - 모듈의 각 파트는 나머지 파트와 연결되어 있고 기능상 필요한 모든 것이 모듈에 존재한다.
- 순차적 응집(sequential cohesion)
    - 두 모듈이, 한쪽에 데이터를 출력하면 다른 쪽이 그것을 입력 받는 형태로 상호작용한다.
- 소통적 응집(communication cohesion)
    - 두 모듈이, 각자 정보에 따라 작동하거나 어떤 출력을 내는 형태로 통신 체인을 형성한다.
- 절차적 응집(procedural cohesion)
    - 두 모듈은 정해진 순서대로 실행된다.
- 일시적 응집(temporal cohesion)
    - 모듈이 시점 의존성(timing dependency)에 따라 연관된다.
- 논리적 응집(logical cohesion)
    - 기능이 아닌 논리적으로 응집되어있다. 자바 프로젝트의 StringUtils 패키지가 좋은 예.
- 동시적 응집(coincidental cohesion)
    - 같은 소스 파일에 모듈 구성요소가 들어가있지만 아무런 연관성이 없다.

LCOM(Lack of Cohesion in Methods)

카이댐버와 케메러의 매서드의 응집 결여도이다. 공유 필드를 통해 공유되지 않는 메서드의 총 개수를 뜻한다.

$$
LCOM96b = \frac{1}{a}\sum_{k=0}^{a}
\frac{m-\mu(Aj)}{m}
$$

### 커플링

추상도(abstractness)는 추상 클래스, 인터페이스 등의 추상 아티팩트(abstract artifact)와 구상 아티팩트(concrete artifact, 구현체)의 비율, 즉 구현 대비 추상화를 나타낸다.

$$
A(추상도) = \frac{\sum m^a}{\sum m^c}
$$

불안정도(instanbility)는 코드베이스의 변동성을 의미한다. 원심 커플링과 (구심 커플링 + 원심 커플링)의 비율로 계산한다.

구심커플링은 컴포넌트, 클래스, 함수 등의 코드 아티팩트로 유입되는 접속 수를 의미한다.

원심 커플링은 다른 코드 아티팩트로 유출되는 접속 수를 나타낸다.

$$
I(불안정도)=\frac{C^e}{C^e+C^a}
$$

메인 시퀀스로부터의 거리(distance from the main sequence)

추상도와 불안정도를 이용하여 이상적인 관계를 계산한다.

$$
D = |A+I-1|
$$

- 그래프가 오른쪽 위로 치우칠 경우
    - 쓸모없는 구역(zone of useless)
    - 추상화를 너무 많이해서 사용하기 어려운 코드
- 그래프가 왼쪽 아래로 치우칠 경우
    - 고통스러운 구역(zone of pain)
    - 추상화를 거의 안하고 구현만 잔뜩 넣어 취약하고 관리하기 어려운 코드

### 커네이선스

두 컴포넌트 중 한쪽이 변경될 경우 다른 쪽도 변경해야 전체 시스템 정합성이 맞는다면 커네이선스를 갖는다.

커네이선스는 정적 커네이선스와 동적 커네이선스로 분류할 수 있다.

- 정적 커네이선스(static connascence)
    - 소스 코드 레벨의 커플링으로 구심/원심 커플링을 발전시킨 개념
    - 명칭 커네이선스(CoN)
        - 여러 컴포넌트의 엔티티명이 일치해야 한다.
    - 타입 커네이선스(CoT)
        - 여러 컴포넌트의 엔티티 타입이 일치해야 한다.
    - 의미 커네이선스(CoM) 또는 관례 커네이선스(CoC)
        - 여러 컴포넌트에 걸쳐 어떤 값의 의미가 일치해야 한다.
        - 예) 상수 대신 숫자를 하드코딩하는 경우
    - 위치 커네이선스(CoP)
        - 여러 컴포넌트는 값의 순서가 일치해야 한다.
        - 예) 매개변수
    - 알고리즘 커네이선스(CoA)
        - 여러 컴포넌트는 특정 알고리즘이 일치해야 한다.
        - 예) 보안 해시 알고리즘
- 동적 커네이선스(dynamic connascence)
    - 런타임 호출을 분석하는 커네이선스
    - 실행 커네이선스(CoE)
        - 여러 컴포넌트의 실행 순서가 중요하다.
    - 시점 커네이선스(CoT)
        - 여러 컴포넌트의 실행 시점이 중요하다.
        - 예) 동시에 실행 중인 두 스레드 때문에 경합 조건이 발생하여 공동 작업의 결과에 영향을 끼치는 경우
    - 값 커네이선스(CoV)
        - 상호 연관된 다수의 값들을 함께 변경한다.
        - 예) 트랜잭션
    - 식별 커네이선스(Col)
        - 여러 컴포넌트가 동일한 엔티티를 참조한다.
        - 예) 독립적인 두 컴포넌트가 분산 큐같은 자료구조를 공유해서 업데이트 하는 경우

커네이선스 속성은 다음과 같이 분석할 수 있다.

- 강도
    - 아키텍트와 개발자는 더 나은 유형의 커네이선스를 리팩토링해서 코트베이스의 커플링 특성을 개선할 수 있다.
    - 정적 커네이선스는 소스 코드 분석 또는 최신 도구를 이용해 쉽게 개선할 수 있다.
- 지역성
    - 코드베이스의 모듈이 서로 얼마나 가까이 있는가
    - 근접한 코드는 일반적으로 분리된 코드보다 높은 형태의 커네이선스를 가진다.
- 정도
    - 커네이선스가 미치는 영향의 규모
        - 소수의 클래스에 영향을 미치는가, 수많은 클래스에 영향을 미치는가
    - 강한 정도의 커네이선스를 약한 정도의 커네이선스로 전환하는 것이 좋다.

1990년대 커네이선스의 문제점

- 아키텍트가 관심 있어하는 아키텍처의 구조보다 저수준 코드의 세부분을 관찰한다.
- 아키텍트가 내려야할 근본적인 결정에 관한 문제는 다루지 않는다.

# 4 아키텍처 특성 정의

아키텍트는 개발팀과 함께 도메인, 비즈니스 요구사항을 정의할 수 있지만, 주로 소프트웨어로 처리할 일 중 도메인 기능과 직접적인 관련이 없는 모든 것들, 즉 아키텍처 특성을 정의, 발견, 분석하는 일을 수행한다.

비기능 요구사항, 품질 속성이라는 말도 많이 사용하지만 부정적인 인상을 주는 단어로 아키텍처 특성이라는 용어를 선호한다.

아키텍처 특성의 기준은 다음과 같다.

- 비도메인 설계 고려 사항을 명시한다.
    - 애플리케이션으로 처리할 일은 구체적인 요구사항으로 정리한다.
    - 요구사항을 구현 하는 방법, 선택을 하게 된 이유와 관련된 운영/설계 기준을 명시한다.
- 설계의 구조적 측면에 영향을 미친다.
    - 이 아키텍처 특성은 어떤 특별한 구조적 요소를 고려해야 하는가?
- 애플리케이션 성공에 절대적으로 중요하다.
    - 아키텍처 특성에 따른 설계 복잡도 가중을 고려하여 가급적 아키텍처 특성을 작게 선정하는 일도 중요하다.
    - 아키텍처의 명시적 특성과 암묵적 특성
        - 명시적 특성
            - 요구사항 정의서나 다른 지침서에 개시된 특성
        - 암묵적 특성
            - 요구사항 정의서에 없지만 프로젝트 성공을 위해 필요한 특성
            - 가용성, 신뢰성, 보안 등 애플리케이션의 근간

## 아키텍처 특성 목록

### 운영 아키텍처 특성

- 가용성(availability)
    - 시스템이 얼마나 오랫동안 사용 가능해야 하는가
- 연속성(continuaility)
    - 재해 복구 능력
- 성능(performance)
    - 스트레스 테스트, 피크 분석, 기능의 사용 빈도 분석, 필요 용량, 응답 시간 등
- 복구성(recoverability)
    - 비즈니스 연속성 요구사항, 백업 전략과 하드웨어 다중화 요건에 영향을 미친다.
- 신뢰성/안전(reliability/safety)
    - 시스템에 페일 세이프가 필요한가? 시스템 실패 시 회사에 거액 손실이 발생하는가?
- 견고성(robustness)
    - 프로그램 실행 중 인터넷 접속 끊김, 정전, 하드웨어 실패 등 에러 및 경계 조건을 감당하는 능력
- 확장성(scalability)
    - 유저 수, 요청 수가 늘어나도 시스템이 그에 맞는 성능을 발휘하는 능력

### 구조 아키텍처 특성

- 설정성(configurability)
    - 최종 유저가 편한 인터페이스를 통해 소프트웨어 설정을 쉽게 바꿀 수 있는가?
- 신장성(extensibility)
    - 새로운 기능을 삽입하는 일의 중요성
- 설치성(installability)
    - 필요한 모든 플랫폼에 쉽게 시스템을 설치할 수 있는가?
- 활용성/재사용(leverageability/reuse)
    - 공통 컴포넌트를 여러 제품에 활용할 수 있나?
- 지역성(locality)
    - 데이터 입력/조회하는 화면에서 다국어가 지원되는가?
- 유지보수성(maintainability)
    - 시스템을 얼마나 쉽게 변경/개선할 수 있나?
- 이식성(portability)
    - 하나 이상의 플랫폼에서 시스템을 실행할 수 있나?
- 지원성(supportability)
    - 애플리케이션은 어느 정도의 기술 지원을 필요로 하나? 시스템에서 발생한 에러를 디버깅하려면 로깅 및 기타 기능이 어느 수준으로 뒷받침되어야 하는가?
- 업그레이드성(upgradeability)
    - 이 애플리케이션/솔루션의 구 버전을 새 버전으로 쉽고 빠르게 업그레이드할 수 있는가?

### 아키텍처 공통 특성

- 접근성(accessibility)
    - 색맹, 청각 장애인 등 모든 유저가 접근하는 데 불편함이 없는가?
- 보관성(archivability)
    - 데이터를 따로 아카이빙해야 하나, 아니면 일정 시간 경과 후 삭제해야 하나?
- 인증(authentication)
    - 유저가 본인이 맞다는 것을 증명하기 위해 필요한 보안 요구사항
- 인가(authorization)
    - 유저가 애플리케이션에서 정해진 기능만 사용할 수 있도록 강제하는 보안 요구사항
- 합법성(legal)
    - 시스템 운영상 법적 제약조건이 있는가?
- 프라이버시(privacy)
    - 회사 내부 임직원의 트랜잭션을 외부에 드러내지 않는 기능
- 보안(security)
    - 데이터를 암호화한 후 데이터베이스에 보관해야 하나? 내부 시스템 간 네트워크 통신도 암호화해야 하나? 원격 유저 액세스는 어떤 종류의 인증이 필요한가?
- 사용성/성취성(usability/achieveability)
    - 유저가 애플리케이션/솔루션을 이용하여 원하는 목적을 달성하기 위해 필요한 교육/훈련 수준

### 최고의 아키텍처를 고집하지 말고 나쁜 것 중에서 제일 나은 아키텍처를 선택하라

아키텍처가 내린 결정은 상충되는 여러 문제들이 뒤얽힌 트레이드오프로 귀결되는 경우가 많다.

애자일 소프트웨어의 교훈과 같이, 가능한 한 아키텍처 설계를 꾸준히 반복해보는 것이 좋다.

# 5 아키텍처 특성 식별

아키텍처는 세 가지 출처 즉 도메인 관심사, 요구사항, 암묵적 도메인 지식에서 아키텍처 특성을 밝혀낸다.

## 도메인 관심사에서 아키텍처 특성 도출

도메인 이해관계자와 협력하여 주요 아키텍처 특성을 정의할 때 최종 목록을 가능한 한 짧게 하는 것이 좋다.

너무 많은 아키텍처 특성을 수용하여 제네릭 아키텍처를 설계하려 하는 것은 안티패턴이다. 아키텍트와 개발자가 당초 의도했던 문제 영역의 해결을 시도하기도 전에 아키텍처가 너무 복잡해져버린다.

주요 담당자들에게 가장 중요한 아키텍처 특성 3개를 선택하라고 한 다음 합의를 이끌어내는 것도 좋은 방법이다. 가장 중요한 것이 무엇일까 논의하고, 아키텍트가 중요한 결정을 내리기 전에 트레이드오프를 분석하는 데에도 도움이 된다.

대부분의 아키텍처 특성은 핵심 도메인 이해관계자들의 의견을 듣고 도메인 관점에서 무엇이 중요한지 의견을 교환하면서 정리한다. 아키텍트와 도메인 이해관계자들이 다른 언어로 소통하는 문제를 막기 위해 도메인 관심사를 아키텍처 특성으로 옮기는 작업이 필요하다.

## 요구사항에서 아키텍처 특성 도출

요구사항 정의서에 명시된 문장에서 도출되는 아키텍처 특성도 있다. 아키텍트가 알고 있는 도메인 지식에서 도출되는 특성들이 있기 때문에 아키텍트가 도메인 지식을 갖고 있으면 이롭다.

## 명시적 특성과 암묵적 특성

- 명시적 특성
    - 필요한 설계의 일부로서 요구사항 정의서에 기술된다.
- 암묵적 특성
    - 요구사항 정의서에 따로 없는 아키텍처 특성도 있지만 각각 중요한 설계 요소가 된다.
    - 예) 가용성, 신뢰성, 보안이 있을 수 있고 중요도에 따라 우선순위가 달라질 수 있다.

# 6 아키텍처 특성의 측정 및 거버넌스

## 아키텍처 특성 측정

아키텍처 특성은 모호할 수 있어 객관적으로 정의할 필요가 있다.

- 물리학이 아니다
    - 동일한 용어도 업계에서 바라보는 시각이 다르다.
    - 법적인 상황이나 우발적으로 의미가 정해지는 경우도 있다.
- 정의가 너무 다양하다
    - 개발자, 아키텍트, 운영자 모두 정의를 통일할 필요가 있다.
- 너무 복합적이다.
    - 바람직한 아키텍처 특성은 대부분 더 작은 여러 특성들로 구성된다.

복합적인 특성을 더 잘게 나누면 다음과 같다.

- 운영적 특성
    - 팀 목표에 따라 달성 가능한 수치를 목표로 삼는다.
    - 예를 들어 확장성을 모니터링하는 비디오 스트리밍 서비스 업체라면 시간에 따라 어떤 추이를 보이는지 측정하고 통계 모델을 수립한다.
- 구조적 특성
    - 내부 구조에 관한 특성은 목표치가 확실하지 않다. 이러한 경우 다른 메트릭과 공통 도구를 이용해서 코드 구조에 관한 부분을 볼 수 있다.
    - 예를 들어 코드의 복잡도는 순환 복잡도(CC, cyclomatic complexity)라는 메트릭을 통해 측정할 수 있다.
        - CC는 함수/메서드, 클래스, 또는 애플리케이션에서 코드 복잡도를 객관적으로 나타내는 지표
        - CC = E-N+2P (P는 연결된 컴포넌트 수)
        - 업계 기준은 10 이하를 권장하나, 5 이하로 나와야 괜찬은 짜임새있는 코드
- 프로세스 측정
    - 소프트웨어 개발 프로세스와 교차하는 아키텍처 특성도 있다.
    - 민첩성은 시험성, 배포성 등의 특성으로 나눌 수 있는 복합적인 아키텍처 특성이다.

## 거버넌스와 피트니스 함수

아키텍처 거버넌스란 아키텍트가 영향력을 행사하려는 모든 소프트웨어 개발 프로세스를 포괄한다.

익스트림 프로그래밍에서 비롯된 소프트웨어 프로젝트의 자동화 움직임은 지속적 통합으로 발전하고, 운영도 자동화하는 데브옵스 체계에 이르렀으며 좋은 솔루션이 많이 등장하고 있다.

아키텍처 피트니스 함수

아키텍처 거버넌스의 여러 부문을 자동화하기 위해 피트니스 함수를 사용한다. 피트니스 함수는 결과가 목표에 얼마나 근접했는지를 나타내는 목표 함수이다.

아키텍처 피트니스 함수는 어떤 아키텍처 특성(또는 그런 특성들의 조합)의 객관적인 무결성을 평가하는 모든 매커니즘이다.

아키텍처 특성에 따라 피트니스 함수를 다양한 도구로 구현할 수 있다.

모듈성의 다양한 측면을 태스트하는 피트니스 함수를 소개한다.

### 순환 의존성

순환 의존성이 형성되면 개발자가 어느 한 컴포넌트를 재사용하기 위해 그에 딸린 다른 컴포넌트들도 함께 가져와야 하므로 모듈성이 매우 떨어진다. 또 컴포넌트 간에 커플링이 증카할 수록 아키텍트는 안티패턴에서 헤어나오지 못한다. 아키텍트는 JDepend라는 메트릭 도구로 패키지 간 의존성을 체크할 수 있다. 이 테스트를 프로젝트의 지속적 빌드의 일부로 장치하여 순환 참조를 방지할 수 있다.

### ‘메인 시퀀스로부터의 거리’ 피트니스 함수

‘메인 시퀀스로부터의 거리’와 같은 난해한 메트릭도 피트니스 함수를 이용해 확인할 수 있다. JDepend로 수용 가능한 임계치를 설정하고 클래스가 범위를 벗어나면 테스트를 실패 처리한다.

아키텍트는 개발자에게 피트니스 함수 사용을 권하기 전에 정확한 목적을 이해할 수 있도록 설명해야한다.

최근 수년 간 피트니스 함수 도구는 점점 더 정교해졌고 목적에 따라 특화되는 추세이다. JUnit의 영향을 받아 탄생한 ArchUnit은 레이어 간의 올바른 관계를 정의하고 실천하는 검증 피트니스 함수 코드를 제공한다. 넷플릭스의 카오스 멍키(Chaos Monkey), 시미안 아미(Simian Army)도 피트니스 함수의 응용 사례이다.
